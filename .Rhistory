mdl_h0_simu$stdev[[2]]==mdl_h0$stdev[[2]]
LT_h1 <- mdl_h1$logLike
LRT_0 = compu_tstat(theta_0, mdl_h0_simu, LT_h1, p, q, k0, exog)
LRT_0
mdl_h0_control <- mdl_h0$control
mdl_h1_control <- mdl_h1$control
LRN_tmp = LR_samp_dist(mdl_h0_simu, k1, N, burnin, Z, mdl_h0_control, mdl_h1_control);
LRN_tmp
MCpval(LRT_0,LRN_tmp)
LRT_0
LRT_0 = compu_tstat(theta_0, mdl_h0_simu, LT_h1, p, q, k0, exog)
LRT_0
library(MSTest)
fig_out   <- "/Users/gabrielrodriguez/Dropbox/Res/papers/MC_LRT_MSM/mc_lrt_msm/empirical/figures/"
res_out   <- "/Users/gabrielrodriguez/Dropbox/Res/papers/MC_LRT_MSM/mc_lrt_msm/empirical/results/"
data_loc  <- "/Users/gabrielrodriguez/Dropbox/Res/papers/MC_LRT_MSM/mc_lrt_msm/data/"
seed      <- 1234
p         <- 1
k1        <- 1
k2        <- 2
k3        <- 3
k4        <- 4
N         <- 99
workers   <- 9
burnin    <- 100
diff_init <- 10
mmc_eps   <- 0
mmc_CI    <- TRUE
mmc_maxit <- 50
ar_control                <- list(const = TRUE,
getSE = TRUE)
msar_control_msmu_msvar   <- list(msmu   = TRUE,
msvar  = TRUE,
method = "EM",
use_diff_init = diff_init,
getSE  = TRUE)
msar_control_msmu <- msar_control_msvar <- msar_control_msmu_msvar
msar_control_msmu$msvar <- FALSE
msar_control_msvar$msmu <- FALSE
# ============================================================================ #
# --------------------------------- DATA -------------------------------------
# ============================================================================ #
StartDate <- "1985-01-01"
EndDate_precov   <- "2019-10-01"
EndDate_poscov   <- "2022-10-01"
EndDate <- EndDate_poscov
# US Data
USgdp <- read.csv(paste0(data_loc,"US_GDP_19600401_20230701.csv"))
USip  <- read.csv(paste0(data_loc,"US_IP_19190401_20240101.csv"))
USgdp <- USgdp[which(USgdp[,1]==StartDate):which(USgdp[,1]==EndDate),3]
USip  <- USip[which(USip[,1]==StartDate):which(USip[,1]==EndDate),3]
# CA Data
CAgdp <- read.csv(paste0(data_loc,"CA_GDP_19610401_20230701.csv"))
CAip  <- read.csv(paste0(data_loc,"CA_IP_19610401_20231001.csv"))
CAgdp <- CAgdp[which(CAgdp[,1]==StartDate):which(CAgdp[,1]==EndDate),3]
CAip  <- CAip[which(CAip[,1]==StartDate):which(CAip[,1]==EndDate),3]
# UK Data
UKgdp <- read.csv(paste0(data_loc,"UK_GDP_19600401_20230701.csv"))
UKip  <- read.csv(paste0(data_loc,"UK_IP_19480401_20240101.csv"))
UKgdp <- UKgdp[which(UKgdp[,1]==StartDate):which(UKgdp[,1]==EndDate),3]
UKip  <- UKip[which(UKip[,1]==StartDate):which(UKip[,1]==EndDate),3]
# GR Data
GRgdp <- read.csv(paste0(data_loc,"GR_GDP_19700401_20230701.csv"))
GRip  <- read.csv(paste0(data_loc,"GR_IP_19580401_20240101.csv"))
GRgdp <- GRgdp[which(GRgdp[,1]==StartDate):which(GRgdp[,1]==EndDate),3]
GRip  <- GRip[which(GRip[,1]==StartDate):which(GRip[,1]==EndDate),3]
# Business Cycle Indicator
BCind <- read.csv(paste0(data_loc,"FRED_NBER_BC_Indicator_quarterly.csv"))
dates <- as.Date(BCind[which(BCind[,1]==StartDate):which(BCind[,1]==EndDate),1])
BCind <- as.matrix(BCind[which(BCind[,1]==StartDate):which(BCind[,1]==EndDate),2])
# Bi-variate Variables.
Y_US_CA_gdp <- cbind(USgdp,CAgdp)
Y_US_CA_ip  <- cbind(USip,CAip)
Y_US_UK_gdp <- cbind(USgdp,UKgdp)
Y_US_UK_ip  <- cbind(USip,UKip)
Y_US_GR_gdp <- cbind(USgdp,GRgdp)
Y_US_GR_ip  <- cbind(USip,GRip)
k0 <-2
k1 <-3
Y <- Y_US_CA_gdp
N                 <- 19#99
Nsim              <- 10#500
workers           <- 10#as.integer(Sys.getenv("SLURM_CPUS_PER_TASK"))
burnin            <- 50
est_diff_init     <- 20   # Number of initial values of use when estimating
simu_diff_init    <- 20   # Number of initial values of use when estimating models from simulated data (for null dist.)
mmc_control <- list(N        = N,
burnin   = burnin,
type     = "pso",
eps      = 0,
CI_union = TRUE,
silence  = FALSE,
threshold_stop      = 0.05 + 1e-10,
variance_constraint = 0.1,
mdl_h0_control = list(getSE  = FALSE),
mdl_h1_control = list(getSE  = FALSE,
maxit  = 1000,
thtol  = 1e-4,
use_diff_init = est_diff_init),
use_diff_init_sim = simu_diff_init,
maxit = 50,
optim_control = list(s=5))
msmu            <- FALSE
msvar           <- TRUE
mmc_control$mdl_h0_control$msmu   <- msmu
mmc_control$mdl_h0_control$msvar  <- msvar
mmc_control$mdl_h1_control$msmu   <- msmu
mmc_control$mdl_h1_control$msvar  <- msvar
control <- mmc_control
Z <- NULL
# ----- Set control values
con <- list(N = 99,
burnin = 100,
converge_check = NULL,
workers = 0,
type = "pso",
eps = 0.1,
CI_union = TRUE,
lambda = 100,
stationary_constraint = TRUE,
phi_low = NULL,
phi_upp = NULL,
P_low = 0,
P_upp = 1,
variance_constraint = 0.01,
silence = FALSE,
threshold_stop = 1,
mdl_h0_control = list(getSE = TRUE),
mdl_h1_control = list(getSE = TRUE),
use_diff_init_sim = NULL,
maxit = 50,
optim_control = list())
# ----- Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
if(length(noNms <- namc[!namc %in% nmsC])){
warning("unknown names in control: ", paste(noNms,collapse=", "))
}
# ----- Perform other checks
if (is.matrix(Y)){
q <- ncol(Y)
}else{
stop("Observations Y must be a (T x q) matrix.")
}
if ((con$CI_union==TRUE) & ((con$mdl_h0_control$getSE==FALSE) | (con$mdl_h1_control$getSE==FALSE))){
con$mdl_h0_control$getSE <- TRUE
con$mdl_h1_control$getSE <- TRUE
warning("getSE was changed to be 'TRUE' because CI_union is 'TRUE'.")
}
# ----- Estimate models using observed data
mdl_h0 <- estimMdl(Y, p, q, k0, Z, con$mdl_h0_control)
mdl_h0_control
con$mdl_h0_control
Y
p
q
k0
mdl_h0 <- estimMdl(Y, p, q, k0, Z, con$mdl_h0_control)
mmc_control$mdl_h0_control$msmu
mmc_control$mdl_h0_control$msvar
mmc_control$mdl_h1_control$msmu
mmc_control$mdl_h1_control$msvar
mdl_h1 <- estimMdl(Y, p, q, k1, Z, con$mdl_h1_control)
k0
(con$msmu==FALSE)
con
control <- mmc_control$mdl_h0_control
con <- list(getSE = TRUE,
msmu = TRUE,
msvar = TRUE,
init_theta = NULL,
method = "EM",
maxit = 1000,
thtol = 1.e-6,
maxit_converge = 500,
use_diff_init = 1,
mle_stationary_constraint = TRUE,
mle_variance_constraint = 1e-3,
mle_theta_low = NULL,
mle_theta_upp = NULL)
# ----- Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
if(length(noNms <- namc[!namc %in% nmsC])){
warning("unknown names in control: ", paste(noNms,collapse=", "))
}
if (k<2){
stop("value for 'k' must be greater than or equal to 2.")
}
k=2
con <- list(getSE = TRUE,
msmu = TRUE,
msvar = TRUE,
init_theta = NULL,
method = "EM",
maxit = 1000,
thtol = 1.e-6,
maxit_converge = 500,
use_diff_init = 1,
mle_stationary_constraint = TRUE,
mle_variance_constraint = 1e-3,
mle_theta_low = NULL,
mle_theta_upp = NULL)
# ----- Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
if(length(noNms <- namc[!namc %in% nmsC])){
warning("unknown names in control: ", paste(noNms,collapse=", "))
}
if (k<2){
stop("value for 'k' must be greater than or equal to 2.")
}
# ---------- Optimization options
optim_options <- list(maxit = con$maxit, thtol = con$thtol)
# pre-define list and matrix length for results
output_all <- list()
max_loglik <- matrix(0, con$use_diff_init, 1)
# ---------- Estimate linear model to use for initial values & transformed series
init_control <- list(const = TRUE, getSE = FALSE)
init_mdl <- VARmdl(Y, p = p, control = init_control)
init_mdl$msmu <- con$msmu
init_mdl$msvar <- con$msvar
if (is.null(con$init_theta)==TRUE){
if (con$method=="EM"){
# ----- Estimate using 'use_diff_init' different initial values
for (xi in 1:con$use_diff_init){
init_used <- 0
converge_check <- FALSE
while ((converge_check==FALSE) & (init_used<con$maxit_converge)){
# ----- Initial values
theta_0 <- initVals_MSVARmdl(init_mdl, k)
# ----- Estimate using EM algorithm and initial values provided
output_tmp <- MSVARmdl_em(theta_0, init_mdl, k, optim_options)
# ----- Convergence check
logLike_tmp <- output_tmp$logLike
theta_tmp <- output_tmp$theta
converge_check <- ((is.finite(output_tmp$logLike)) & (all(is.finite(output_tmp$theta))))
init_used <- init_used + 1
}
output_tmp$theta_0 <- theta_0
max_loglik[xi] <- output_tmp$logLike
output_tmp$init_used <- init_used
output_all[[xi]] <- output_tmp
}
}else if (con$method=="MLE"){
optim_options$mle_theta_low <- con$mle_theta_low
optim_options$mle_theta_upp <- con$mle_theta_upp
init_mdl$mle_stationary_constraint <- con$mle_stationary_constraint
init_mdl$mle_variance_constraint <- con$mle_variance_constraint
# ----- Estimate using 'use_diff_init' different initial values
for (xi in 1:con$use_diff_init){
init_used <- 0
converge_check <- FALSE
while ((converge_check==FALSE) & (init_used<con$maxit_converge)){
# ----- Initial values
theta_0 <- initVals_MSVARmdl(init_mdl, k)
# ----- Estimate using roptim and initial values provided
output_tmp <- NULL
try(
output_tmp <- MSVARmdl_mle(theta_0, init_mdl, k, optim_options)
)
# ----- Convergence check
if (is.null(output_tmp)==FALSE){
converge_check <- TRUE
}else{
converge_check <- FALSE
}
init_used = init_used + 1
}
output_tmp$theta_0 <- theta_0
max_loglik[xi] <- output_tmp$logLike
output_tmp$init_used <- init_used
output_all[[xi]] <- output_tmp
}
}
if (con$use_diff_init==1){
output = output_tmp
}else{
xl = which.max(max_loglik)
if (length(xl)==0){
warning("Model(s) did not converge. Use higher 'use_diff_init' or 'maxit_converge'.")
output <- output_all[[1]]
}else{
output <- output_all[[xl]]
}
}
}else{
if (con$method=="EM"){
# ----- Estimate using EM algorithm and initial values provided
output <- MSVARmdl_em(con$init_theta, init_mdl, k, optim_options)
output$theta_0 <- con$init_theta
output$init_used <- 1
}else if (con$method=="MLE"){
optim_options$lower <- con$lower
optim_options$upper <- con$upper
init_mdl$mle_stationary_constraint <- con$mle_stationary_constraint
init_mdl$mle_variance_constraint <- con$mle_variance_constraint
# ----- Estimate using roptim and initial values provided
output <- MSVARmdl_mle(con$init_theta, init_mdl, k, optim_options)
output$theta_0 <- con$init_theta
output$init_used <- 1
}
}
q <- ncol(Y)
output$Fmat    <- companionMat(output$phi, p, q)
inter <- matrix(0,k,q)
beta <- list()
stdev <- list()
for(xk in 1:k){
nu_tmp <- (diag(q*p)-output$Fmat)%*%as.matrix(c(output$mu[xk,],rep(0,q*(p-1))))
inter[xk,] <- nu_tmp[(1:(q))]
beta[[xk]] <- rbind(inter[xk,],t(output$phi))
stdev[[xk]] = diag(sqrt(diag(output$sigma[[xk]])))
}
q <- ncol(Y)
output$Fmat    <- companionMat(output$phi, p, q)
inter <- matrix(0,k,q)
beta <- list()
stdev <- list()
for(xk in 1:k){
nu_tmp <- (diag(q*p)-output$Fmat)%*%as.matrix(c(output$mu[xk,],rep(0,q*(p-1))))
inter[xk,] <- nu_tmp[(1:(q))]
beta[[xk]] <- rbind(inter[xk,],t(output$phi))
stdev[[xk]] = diag(sqrt(diag(output$sigma[[xk]])))
}
output$mu
p
output
library(MSTest)
fig_out   <- "/Users/gabrielrodriguez/Dropbox/Res/papers/MC_LRT_MSM/mc_lrt_msm/empirical/figures/"
res_out   <- "/Users/gabrielrodriguez/Dropbox/Res/papers/MC_LRT_MSM/mc_lrt_msm/empirical/results/"
data_loc  <- "/Users/gabrielrodriguez/Dropbox/Res/papers/MC_LRT_MSM/mc_lrt_msm/data/"
seed      <- 1234
p         <- 1
k1        <- 1
k2        <- 2
k3        <- 3
k4        <- 4
N         <- 99
workers   <- 9
burnin    <- 100
diff_init <- 10
mmc_eps   <- 0
mmc_CI    <- TRUE
mmc_maxit <- 50
ar_control                <- list(const = TRUE,
getSE = TRUE)
msar_control_msmu_msvar   <- list(msmu   = TRUE,
msvar  = TRUE,
method = "EM",
use_diff_init = diff_init,
getSE  = TRUE)
msar_control_msmu <- msar_control_msvar <- msar_control_msmu_msvar
msar_control_msmu$msvar <- FALSE
msar_control_msvar$msmu <- FALSE
# ============================================================================ #
# --------------------------------- DATA -------------------------------------
# ============================================================================ #
StartDate <- "1985-01-01"
EndDate_precov   <- "2019-10-01"
EndDate_poscov   <- "2022-10-01"
EndDate <- EndDate_poscov
# US Data
USgdp <- read.csv(paste0(data_loc,"US_GDP_19600401_20230701.csv"))
USip  <- read.csv(paste0(data_loc,"US_IP_19190401_20240101.csv"))
USgdp <- USgdp[which(USgdp[,1]==StartDate):which(USgdp[,1]==EndDate),3]
USip  <- USip[which(USip[,1]==StartDate):which(USip[,1]==EndDate),3]
# CA Data
CAgdp <- read.csv(paste0(data_loc,"CA_GDP_19610401_20230701.csv"))
CAip  <- read.csv(paste0(data_loc,"CA_IP_19610401_20231001.csv"))
CAgdp <- CAgdp[which(CAgdp[,1]==StartDate):which(CAgdp[,1]==EndDate),3]
CAip  <- CAip[which(CAip[,1]==StartDate):which(CAip[,1]==EndDate),3]
# UK Data
UKgdp <- read.csv(paste0(data_loc,"UK_GDP_19600401_20230701.csv"))
UKip  <- read.csv(paste0(data_loc,"UK_IP_19480401_20240101.csv"))
UKgdp <- UKgdp[which(UKgdp[,1]==StartDate):which(UKgdp[,1]==EndDate),3]
UKip  <- UKip[which(UKip[,1]==StartDate):which(UKip[,1]==EndDate),3]
# GR Data
GRgdp <- read.csv(paste0(data_loc,"GR_GDP_19700401_20230701.csv"))
GRip  <- read.csv(paste0(data_loc,"GR_IP_19580401_20240101.csv"))
GRgdp <- GRgdp[which(GRgdp[,1]==StartDate):which(GRgdp[,1]==EndDate),3]
GRip  <- GRip[which(GRip[,1]==StartDate):which(GRip[,1]==EndDate),3]
# Business Cycle Indicator
BCind <- read.csv(paste0(data_loc,"FRED_NBER_BC_Indicator_quarterly.csv"))
dates <- as.Date(BCind[which(BCind[,1]==StartDate):which(BCind[,1]==EndDate),1])
BCind <- as.matrix(BCind[which(BCind[,1]==StartDate):which(BCind[,1]==EndDate),2])
# Bi-variate Variables.
Y_US_CA_gdp <- cbind(USgdp,CAgdp)
Y_US_CA_ip  <- cbind(USip,CAip)
Y_US_UK_gdp <- cbind(USgdp,UKgdp)
Y_US_UK_ip  <- cbind(USip,UKip)
Y_US_GR_gdp <- cbind(USgdp,GRgdp)
Y_US_GR_ip  <- cbind(USip,GRip)
k0 <-2
k1 <-3
Y <- Y_US_CA_gdp
N                 <- 19#99
Nsim              <- 10#500
workers           <- 10#as.integer(Sys.getenv("SLURM_CPUS_PER_TASK"))
burnin            <- 50
est_diff_init     <- 20   # Number of initial values of use when estimating
simu_diff_init    <- 20   # Number of initial values of use when estimating models from simulated data (for null dist.)
mmc_control <- list(N        = N,
burnin   = burnin,
type     = "pso",
eps      = 0,
CI_union = TRUE,
silence  = FALSE,
threshold_stop      = 0.05 + 1e-10,
variance_constraint = 0.1,
mdl_h0_control = list(getSE  = FALSE),
mdl_h1_control = list(getSE  = FALSE,
maxit  = 1000,
thtol  = 1e-4,
use_diff_init = est_diff_init),
use_diff_init_sim = simu_diff_init,
maxit = 50,
optim_control = list(s=5))
msmu            <- FALSE
msvar           <- TRUE
mmc_control$mdl_h0_control$msmu   <- msmu
mmc_control$mdl_h0_control$msvar  <- msvar
mmc_control$mdl_h1_control$msmu   <- msmu
mmc_control$mdl_h1_control$msvar  <- msvar
control <- mmc_control
Z <- NULL
# ----- Set control values
con <- list(N = 99,
burnin = 100,
converge_check = NULL,
workers = 0,
type = "pso",
eps = 0.1,
CI_union = TRUE,
lambda = 100,
stationary_constraint = TRUE,
phi_low = NULL,
phi_upp = NULL,
P_low = 0,
P_upp = 1,
variance_constraint = 0.01,
silence = FALSE,
threshold_stop = 1,
mdl_h0_control = list(getSE = TRUE),
mdl_h1_control = list(getSE = TRUE),
use_diff_init_sim = NULL,
maxit = 50,
optim_control = list())
# ----- Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
if(length(noNms <- namc[!namc %in% nmsC])){
warning("unknown names in control: ", paste(noNms,collapse=", "))
}
# ----- Perform other checks
if (is.matrix(Y)){
q <- ncol(Y)
}else{
stop("Observations Y must be a (T x q) matrix.")
}
if ((con$CI_union==TRUE) & ((con$mdl_h0_control$getSE==FALSE) | (con$mdl_h1_control$getSE==FALSE))){
con$mdl_h0_control$getSE <- TRUE
con$mdl_h1_control$getSE <- TRUE
warning("getSE was changed to be 'TRUE' because CI_union is 'TRUE'.")
}
# ----- Estimate models using observed data
mdl_h0 <- estimMdl(Y, p, q, k0, Z, con$mdl_h0_control)
mdl_h1 <- estimMdl(Y, p, q, k1, Z, con$mdl_h1_control)
con$mdl_h0_control <- mdl_h0$control
con$mdl_h1_control <- mdl_h1$control
# ----- Optional model convergence checks
if (is.null(con$converge_check)==FALSE){
if ((con$converge_check=="null") & (mdl_h0$converged==FALSE)){
stop("Model under null hypothesis did not converge. Run again to use different initial values and/or increase 'maxit' for restricted model.")
}
if ((con$converge_check=="alt") & (mdl_h1$converged==FALSE)){
stop("Model under alternative hypothesis did not converge. Run again to use different initial values and/or increase 'maxit' for unrestricted model.")
}
if ((con$converge_check=="both") & ((mdl_h0$converged==FALSE) | (mdl_h1$converged==FALSE))){
stop("Model did not converge. Run again to use different initial values and/or increase 'maxit' for each models.")
}
}
theta_0 <- mdl_h0$theta
# ----- Define lower & upper bounds for search
mmc_bounds <- MMC_bounds(mdl_h0, con)
theta_low <- mmc_bounds$theta_low
theta_upp <- mmc_bounds$theta_upp
# ----- Search for Max p-value within bounds
mdl_h0_null_cont <- con$mdl_h0_control
mdl_h1_null_cont <- con$mdl_h1_control
if (is.null(con$use_diff_init_sim)==FALSE){
mdl_h0_null_cont$use_diff_init <- con$use_diff_init_sim
mdl_h1_null_cont$use_diff_init <- con$use_diff_init_sim
}
if (is.null(Z)==FALSE){
Zsim <- Z[(p+1):nrow(Z),,drop=F]
exog <- TRUE
}else{
Zsim <- Z
exog <- FALSE
}
mdl_h0_simu  = mdledit(mdl_h0, theta_0, p, q, k0, exog)
mdl_h0_simu$mu==mdl_h0$mu
mdl_h0_simu$sigma[[1]]==mdl_h0$sigma[[1]]
mdl_h0_simu$stdev[[2]]==mdl_h0$stdev[[2]]
mdl_h0_simu$mu
mdl_h0_simu$sigma
mdl_h0
mdl_h0$sigma
theta_0 <- initVals_HMmdl(init_mdl, k)
init_mdl
HMmdl
