warning("unknown names in control: ", paste(noNms,collapse=", "))
}
# ---------- Optimization options
optim_options <- list(maxit = con$maxit, thtol = con$thtol)
# pre-define list and matrix length for results
output_all <- list(con$use_diff_init)
max_loglik <- matrix(0, con$use_diff_init, 1)
# ---------- Estimate linear model to use for initial values & transformed series
init_control <- list(const = con$const, getSE = FALSE)
init_mdl <- VARmdl(Y, p = p, init_control)
init_mdl$msmu <- con$msmu
init_mdl$msvar <- con$msvar
p=1
k
k=2
con <- list(const = TRUE,
getSE = TRUE,
msmu = TRUE,
msvar = TRUE,
method = "EM",
maxit = 10000,
thtol = 1.e-6,
max_init = 500,
use_diff_init = 1,
init_value = NULL)
# Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
if(length(noNms <- namc[!namc %in% nmsC])){
warning("unknown names in control: ", paste(noNms,collapse=", "))
}
# ---------- Optimization options
optim_options <- list(maxit = con$maxit, thtol = con$thtol)
# pre-define list and matrix length for results
output_all <- list(con$use_diff_init)
max_loglik <- matrix(0, con$use_diff_init, 1)
# ---------- Estimate linear model to use for initial values & transformed series
init_control <- list(const = con$const, getSE = FALSE)
init_mdl <- VARmdl(Y, p = p, init_control)
init_mdl$msmu <- con$msmu
init_mdl$msvar <- con$msvar
init_used <- 0
converge_check <- FALSE
theta_0 <- initVals_MSVARmdl(init_mdl, k)
theta <- theta_0
mdl_in <- init_mdl
MSVARmdl_mle_env <- rlang::env()
# set environment variables
MSVARmdl_mle_env$p <- mdl_in$p
MSVARmdl_mle_env$k <- k
MSVARmdl_mle_env$q <- mdl_in$q
MSVARmdl_mle_env$msmu <- mdl_in$msmu
MSVARmdl_mle_env$msvar <- mdl_in$msvar
# MSVARmdl_mle equality constraint functions
loglik_const_eq_MSVARmdl <- function(theta){
k <- get("k", envir = MSVARmdl_mle_env)
P <- matrix(theta[(length(theta)-k*k+1):(length(theta))],k,k)
constraint <- colSums(P)-1
return(constraint)
}
# MSVARmdl_mle inequality constraint functions
loglik_const_ineq_MSVARmdl <- function(theta){
p <- get("p", envir = MSVARmdl_mle_env)
k <- get("k", envir = MSVARmdl_mle_env)
q <- get("q", envir = MSVARmdl_mle_env)
msmu <- get("msmu", envir = MSVARmdl_mle_env)
msvar <- get("msvar", envir = MSVARmdl_mle_env)
Nsig <- (q*(q+1))/2
phi_len <- q*p*q
# get absolute value of eigenvalue of companion matrix
phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
Fmat <- companionMat(phi,p,q)
stationary  <- abs(eigen(Fmat)[[1]])
# transition probabilities
Pvec = theta[(length(theta)-k*k+1):(length(theta))]
# variances
vars <- theta[c(rep(0, q + q*(k-1)*msmu), rep(t(covar_vech(diag(q))), 1+(k-1)*msvar), rep(0, phi_len + k*k))==1] +  0.000001
ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec, vars)
return(ineq_constraint)
}
res <- nloptr::slsqp(x0 = theta_0,
fn = logLike_MSVARmdl_min,
gr = NULL,
lower = NULL,
upper = NULL,
hin = loglik_const_ineq_MSVARmdl,
heq = loglik_const_eq_MSVARmdl,
nl.info = TRUE,
control = list(maxeval = optim_options$maxit, xtol_rel = optim_options$thtol),
mdl = mdl_in,
k = k)
loglik_const_ineq_MSVARmdl(theta_0)
loglik_const_eq_MSVARmdl(theta_0)
MSVARmdl_mle_env <- rlang::env()
# set environment variables
MSVARmdl_mle_env$p <- mdl_in$p
MSVARmdl_mle_env$k <- k
MSVARmdl_mle_env$q <- mdl_in$q
MSVARmdl_mle_env$msmu <- mdl_in$msmu
MSVARmdl_mle_env$msvar <- mdl_in$msvar
# MSVARmdl_mle equality constraint functions
loglik_const_eq_MSVARmdl <- function(theta){
k <- get("k", envir = MSVARmdl_mle_env)
P <- matrix(theta[(length(theta)-k*k+1):(length(theta))],k,k)
constraint <- colSums(P)-1
return(constraint)
}
# MSVARmdl_mle inequality constraint functions
loglik_const_ineq_MSVARmdl <- function(theta){
p <- get("p", envir = MSVARmdl_mle_env)
k <- get("k", envir = MSVARmdl_mle_env)
q <- get("q", envir = MSVARmdl_mle_env)
msmu <- get("msmu", envir = MSVARmdl_mle_env)
msvar <- get("msvar", envir = MSVARmdl_mle_env)
Nsig <- (q*(q+1))/2
phi_len <- q*p*q
# get absolute value of eigenvalue of companion matrix
phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
Fmat <- companionMat(phi,p,q)
stationary  <- abs(eigen(Fmat)[[1]])
# transition probabilities
Pvec = theta[(length(theta)-k*k+1):(length(theta))]
# variances
#vars <- theta[c(rep(0, q + q*(k-1)*msmu), rep(t(covar_vech(diag(q))), 1+(k-1)*msvar), rep(0, phi_len + k*k))==1] +  0.000001
#ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec, vars)
ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec)
return(ineq_constraint)
}
# use nloptr optimization to minimize (maximize) likelihood
res <- nloptr::slsqp(x0 = theta_0,
fn = logLike_MSVARmdl_min,
gr = NULL,
lower = NULL,
upper = NULL,
hin = loglik_const_ineq_MSVARmdl,
heq = loglik_const_eq_MSVARmdl,
nl.info = TRUE,
control = list(maxeval = optim_options$maxit, xtol_rel = optim_options$thtol),
mdl = mdl_in,
k = k)
phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
Nsig <- (q*(q+1))/2
phi_len <- q*p*q
# get absolute value of eigenvalue of companion matrix
phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
q
q <- get("q", envir = MSVARmdl_mle_env)
Nsig <- (q*(q+1))/2
phi_len <- q*p*q
# get absolute value of eigenvalue of companion matrix
phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
p <- get("p", envir = MSVARmdl_mle_env)
k <- get("k", envir = MSVARmdl_mle_env)
q <- get("q", envir = MSVARmdl_mle_env)
msmu <- get("msmu", envir = MSVARmdl_mle_env)
msvar <- get("msvar", envir = MSVARmdl_mle_env)
Nsig <- (q*(q+1))/2
phi_len <- q*p*q
# get absolute value of eigenvalue of companion matrix
phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
phi
Fmat <- companionMat(phi,p,q)
Fmat
eigen(Fmat)
eigen(Fmat)[[1]]
Mod(eigen(Fmat)[[1]])
1-stationary
stationary  <- Mod(eigen(Fmat)[[1]])
ineq_constraint = c(1-stationary, Pvec, 1-Pvec)
Pvec = theta[(length(theta)-k*k+1):(length(theta))]
# variances
#vars <- theta[c(rep(0, q + q*(k-1)*msmu), rep(t(covar_vech(diag(q))), 1+(k-1)*msvar), rep(0, phi_len + k*k))==1] +  0.000001
#ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec, vars)
ineq_constraint = c(1-stationary, Pvec, 1-Pvec)
ineq_constraint
MSVARmdl_mle_env <- rlang::env()
# set environment variables
MSVARmdl_mle_env$p <- mdl_in$p
MSVARmdl_mle_env$k <- k
MSVARmdl_mle_env$q <- mdl_in$q
MSVARmdl_mle_env$msmu <- mdl_in$msmu
MSVARmdl_mle_env$msvar <- mdl_in$msvar
# MSVARmdl_mle equality constraint functions
loglik_const_eq_MSVARmdl <- function(theta){
k <- get("k", envir = MSVARmdl_mle_env)
P <- matrix(theta[(length(theta)-k*k+1):(length(theta))],k,k)
constraint <- colSums(P)-1
return(constraint)
}
# MSVARmdl_mle inequality constraint functions
loglik_const_ineq_MSVARmdl <- function(theta){
p <- get("p", envir = MSVARmdl_mle_env)
k <- get("k", envir = MSVARmdl_mle_env)
q <- get("q", envir = MSVARmdl_mle_env)
msmu <- get("msmu", envir = MSVARmdl_mle_env)
msvar <- get("msvar", envir = MSVARmdl_mle_env)
Nsig <- (q*(q+1))/2
phi_len <- q*p*q
# get absolute value of eigenvalue of companion matrix
phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
Fmat <- companionMat(phi,p,q)
stationary  <- Mod(eigen(Fmat)[[1]])
# transition probabilities
Pvec = theta[(length(theta)-k*k+1):(length(theta))]
# variances
#vars <- theta[c(rep(0, q + q*(k-1)*msmu), rep(t(covar_vech(diag(q))), 1+(k-1)*msvar), rep(0, phi_len + k*k))==1] +  0.000001
#ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec, vars)
ineq_constraint = c(1-stationary, Pvec, 1-Pvec)
return(ineq_constraint)
}
# use nloptr optimization to minimize (maximize) likelihood
res <- nloptr::slsqp(x0 = theta_0,
fn = logLike_MSVARmdl_min,
gr = NULL,
lower = NULL,
upper = NULL,
hin = loglik_const_ineq_MSVARmdl,
heq = loglik_const_eq_MSVARmdl,
nl.info = TRUE,
control = list(maxeval = optim_options$maxit, xtol_rel = optim_options$thtol),
mdl = mdl_in,
k = k)
stationary
eigen(Fmat)[[1]]
1-stationary
loglik_const_ineq_MSVARmdl <- function(theta){
p <- get("p", envir = MSVARmdl_mle_env)
k <- get("k", envir = MSVARmdl_mle_env)
q <- get("q", envir = MSVARmdl_mle_env)
msmu <- get("msmu", envir = MSVARmdl_mle_env)
msvar <- get("msvar", envir = MSVARmdl_mle_env)
Nsig <- (q*(q+1))/2
phi_len <- q*p*q
# get absolute value of eigenvalue of companion matrix
phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
Fmat <- companionMat(phi,p,q)
stationary  <- Mod(eigen(Fmat)[[1]])
# transition probabilities
Pvec = theta[(length(theta)-k*k+1):(length(theta))] + 0.000001
# variances
#vars <- theta[c(rep(0, q + q*(k-1)*msmu), rep(t(covar_vech(diag(q))), 1+(k-1)*msvar), rep(0, phi_len + k*k))==1] +  0.000001
#ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec, vars)
ineq_constraint = c(1-stationary, Pvec, 1-Pvec)
return(ineq_constraint)
}
# use nloptr optimization to minimize (maximize) likelihood
res <- nloptr::slsqp(x0 = theta_0,
fn = logLike_MSVARmdl_min,
gr = NULL,
lower = NULL,
upper = NULL,
hin = loglik_const_ineq_MSVARmdl,
heq = loglik_const_eq_MSVARmdl,
nl.info = TRUE,
control = list(maxeval = optim_options$maxit, xtol_rel = optim_options$thtol),
mdl = mdl_in,
k = k)
loglik_const_ineq_MSVARmdl <- function(theta){
p <- get("p", envir = MSVARmdl_mle_env)
k <- get("k", envir = MSVARmdl_mle_env)
q <- get("q", envir = MSVARmdl_mle_env)
msmu <- get("msmu", envir = MSVARmdl_mle_env)
msvar <- get("msvar", envir = MSVARmdl_mle_env)
Nsig <- (q*(q+1))/2
phi_len <- q*p*q
# get absolute value of eigenvalue of companion matrix
phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
Fmat <- companionMat(phi,p,q)
stationary  <- Mod(eigen(Fmat)[[1]]) + 0.000001
# transition probabilities
Pvec = theta[(length(theta)-k*k+1):(length(theta))]
# variances
#vars <- theta[c(rep(0, q + q*(k-1)*msmu), rep(t(covar_vech(diag(q))), 1+(k-1)*msvar), rep(0, phi_len + k*k))==1] +  0.000001
#ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec, vars)
ineq_constraint = c(1-stationary, Pvec, 1-Pvec)
return(ineq_constraint)
}
# use nloptr optimization to minimize (maximize) likelihood
res <- nloptr::slsqp(x0 = theta_0,
fn = logLike_MSVARmdl_min,
gr = NULL,
lower = NULL,
upper = NULL,
hin = loglik_const_ineq_MSVARmdl,
heq = loglik_const_eq_MSVARmdl,
nl.info = TRUE,
control = list(maxeval = optim_options$maxit, xtol_rel = optim_options$thtol),
mdl = mdl_in,
k = k)
loglik_const_ineq_MSVARmdl <- function(theta){
p <- get("p", envir = MSVARmdl_mle_env)
k <- get("k", envir = MSVARmdl_mle_env)
q <- get("q", envir = MSVARmdl_mle_env)
msmu <- get("msmu", envir = MSVARmdl_mle_env)
msvar <- get("msvar", envir = MSVARmdl_mle_env)
Nsig <- (q*(q+1))/2
phi_len <- q*p*q
# get absolute value of eigenvalue of companion matrix
phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
Fmat <- companionMat(phi,p,q)
stationary  <- Mod(eigen(Fmat)[[1]]) + 0.000001
# transition probabilities
Pvec = theta[(length(theta)-k*k+1):(length(theta))]
# variances
#vars <- theta[c(rep(0, q + q*(k-1)*msmu), rep(t(covar_vech(diag(q))), 1+(k-1)*msvar), rep(0, phi_len + k*k))==1] +  0.000001
#ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec, vars)
ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec)
return(ineq_constraint)
}
# use nloptr optimization to minimize (maximize) likelihood
res <- nloptr::slsqp(x0 = theta_0,
fn = logLike_MSVARmdl_min,
gr = NULL,
lower = NULL,
upper = NULL,
hin = loglik_const_ineq_MSVARmdl,
heq = loglik_const_eq_MSVARmdl,
nl.info = TRUE,
control = list(maxeval = optim_options$maxit, xtol_rel = optim_options$thtol),
mdl = mdl_in,
k = k)
(con$method=="MLE")
con$method = "MLE"
init_used <- 0
converge_check <- FALSE
while ((converge_check==FALSE) & (init_used<con$max_init)){
# ----- Initial values
theta_0 <- initVals_MSVARmdl(init_mdl, k)
if (con$method=="EM"){
# ----- Estimate using EM algorithm and initial values provided
output_tmp <- MSVARmdl_em(theta_0, init_mdl, k, optim_options)
output_tmp$theta_0 = theta_0
# ----- Convergence check
logLike_tmp <- output_tmp$logLike
theta_tmp = output_tmp$theta
converge_check = ((is.finite(output_tmp$logLike)) & (all(is.finite(output_tmp$theta))))
}else if (con$method=="MLE"){
# ----- Estimate using roptim and initial values provided
output_tmp <- NULL
try(
output_tmp <- MSVARmdl_mle(theta_0, init_mdl, k, optim_options)
)
# ----- Convergence check
if (is.null(output_tmp)==FALSE){
output_tmp$theta_0 <- theta_0
converge_check = TRUE
}else{
converge_check = FALSE
}
}
init_used = init_used + 1
}
MSVARmdl_mle_env <- rlang::env()
# set environment variables
MSVARmdl_mle_env$p <- mdl_in$p
MSVARmdl_mle_env$k <- k
MSVARmdl_mle_env$q <- mdl_in$q
MSVARmdl_mle_env$msmu <- mdl_in$msmu
MSVARmdl_mle_env$msvar <- mdl_in$msvar
# MSVARmdl_mle equality constraint functions
loglik_const_eq_MSVARmdl <- function(theta){
k <- get("k", envir = MSVARmdl_mle_env)
P <- matrix(theta[(length(theta)-k*k+1):(length(theta))],k,k)
constraint <- colSums(P)-1
return(constraint)
}
# MSVARmdl_mle inequality constraint functions
loglik_const_ineq_MSVARmdl <- function(theta){
p <- get("p", envir = MSVARmdl_mle_env)
k <- get("k", envir = MSVARmdl_mle_env)
q <- get("q", envir = MSVARmdl_mle_env)
msmu <- get("msmu", envir = MSVARmdl_mle_env)
msvar <- get("msvar", envir = MSVARmdl_mle_env)
Nsig <- (q*(q+1))/2
phi_len <- q*p*q
# get absolute value of eigenvalue of companion matrix
#phi <- t(matrix(theta[c(rep(0, q + q*(k-1)*msmu + Nsig + Nsig*(k-1)*msvar), rep(1, phi_len), rep(0, k*k))==1], q*p, q))
#Fmat <- companionMat(phi,p,q)
#stationary  <- Mod(eigen(Fmat)[[1]]) + 0.000001
# transition probabilities
Pvec = theta[(length(theta)-k*k+1):(length(theta))]
# variances
#vars <- theta[c(rep(0, q + q*(k-1)*msmu), rep(t(covar_vech(diag(q))), 1+(k-1)*msvar), rep(0, phi_len + k*k))==1] +  0.000001
#ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec, vars)
#ineq_constraint = c(stationary, 1-stationary, Pvec, 1-Pvec)
ineq_constraint = c(Pvec, 1-Pvec)
return(ineq_constraint)
}
# use nloptr optimization to minimize (maximize) likelihood
res <- nloptr::slsqp(x0 = theta_0,
fn = logLike_MSVARmdl_min,
gr = NULL,
lower = NULL,
upper = NULL,
hin = loglik_const_ineq_MSVARmdl,
heq = loglik_const_eq_MSVARmdl,
nl.info = TRUE,
control = list(maxeval = optim_options$maxit, xtol_rel = optim_options$thtol),
mdl = mdl_in,
k = k)
devtools::document()
library(MSTest)
y_gnp_gw_84 <- hamilton84GNP$GNP_logdiff
# Set options for model estimation
control <- list(msmu  = TRUE,
msvar = FALSE,
method = "MLE",
use_diff_init = 10)
# Estimate model with p=4 and switch in mean only as in Hamilton (1989)
hamilton89_mdl <- MSARmdl(as.matrix(y_gnp_gw_84), p = 4, k = 2, control)
devtools::document()
library(MSTest)
# Use GNP growth 1951Q2 - 1984Q4
y_gnp_gw_84 <- hamilton84GNP$GNP_logdiff
# Set options for model estimation
control <- list(msmu  = TRUE,
msvar = FALSE,
method = "MLE",
use_diff_init = 10)
# Estimate model with p=4 and switch in mean only as in Hamilton (1989)
hamilton89_mdl <- MSARmdl(as.matrix(y_gnp_gw_84), p = 4, k = 2, control)
devtools::document()
library(MSTest)
y_gnp_gw_84 <- hamilton84GNP$GNP_logdiff
# Set options for model estimation
control <- list(msmu  = TRUE,
msvar = FALSE,
method = "MLE",
use_diff_init = 10)
# Estimate model with p=4 and switch in mean only as in Hamilton (1989)
hamilton89_mdl <- MSARmdl(as.matrix(y_gnp_gw_84), p = 4, k = 2, control)
devtools::document()
library(MSTest)
# Use GNP growth 1951Q2 - 1984Q4
y_gnp_gw_84 <- hamilton84GNP$GNP_logdiff
# Set options for model estimation
control <- list(msmu  = TRUE,
msvar = FALSE,
method = "MLE",
use_diff_init = 10)
# Estimate model with p=4 and switch in mean only as in Hamilton (1989)
hamilton89_mdl <- MSARmdl(as.matrix(y_gnp_gw_84), p = 4, k = 2, control)
hamilton89_mdl$mu
devtools::document()
library(MSTest)
# Use GNP growth 1951Q2 - 1984Q4
y_gnp_gw_84 <- hamilton84GNP$GNP_logdiff
# Set options for model estimation
control <- list(msmu  = TRUE,
msvar = FALSE,
method = "MLE",
use_diff_init = 10)
# Estimate model with p=4 and switch in mean only as in Hamilton (1989)
hamilton89_mdl <- MSARmdl(as.matrix(y_gnp_gw_84), p = 4, k = 2, control)
devtools::document()
library(MSTest)
y_gnp_gw_84 <- hamilton84GNP$GNP_logdiff
# Set options for model estimation
control <- list(msmu  = TRUE,
msvar = FALSE,
method = "MLE",
use_diff_init = 10)
# Estimate model with p=4 and switch in mean only as in Hamilton (1989)
hamilton89_mdl <- MSARmdl(as.matrix(y_gnp_gw_84), p = 4, k = 2, control)
hamilton89_mdl$mu
hamilton89_mdl$sigma
hamilton89_mdl$phi
hamilton89_mdl$P
plot(hamilton89_mdl$St, type = 'l')
plot(hamilton89_mdl$St[,1], type = 'l')
plot(hamilton89_mdl$St[,1], type = 'l')
plot(hamilton89_mdl$St[,2], type = 'l')
mdl_ms2 <- list(n     = 500,
mu    = c(5,10),
sigma = c(1,2),
phi   = c(0.5,0.2),
k     = 2,
P     = rbind(c(0.1,0.9),
c(0.9,0.1)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
control <- list(msmu  = TRUE,
msvar = TRUE,
method = "EM",
use_diff_init = 10)
# Estimate model
y_ms_mdl <- MSARmdl(y_ms_simu$y, ar = y_ms_simu$ar, k = y_ms_simu$k, control)
mdl_ms2 <- list(n     = 500,
mu    = c(5,10),
sigma = c(1,2),
phi   = c(0.5,0.2),
k     = 2,
P     = rbind(c(0.1,0.9),
c(0.9,0.1)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
control <- list(msmu  = TRUE,
msvar = TRUE,
method = "EM",
use_diff_init = 10)
# Estimate model
y_ms_mdl <- MSARmdl(y_ms_simu$y, p = 2, k = 2, control)
y_ms_mdl$mu
y_ms_mdl$sigma
y_ms_mdl$phi
y_ms_mdl$P
devtools::document()
library(MSTest)
devtools::document()
library(MSTest)
