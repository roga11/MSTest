}
}
if (con$use_diff_init==1){
output <- output_tmp
}else{
xl = which.max(max_loglik)
if (length(xl)==0){
warning("Model(s) did not converge. Use higher 'use_diff_init' or 'maxit_converge'.")
output <- output_all[[1]]
}else{
output <- output_all[[xl]]
}
}
}else{
if (con$method=="EM"){
# ----- Estimate using EM algorithm and initial values provided
output <- MSARmdl_em(con$init_theta, init_mdl, k, optim_options)
output$theta_0 <- con$init_theta
output$init_used <- 1
}else if (con$method=="MLE"){
init_mdl$mle_stationary_constraint <- con$mle_stationary_constraint
init_mdl$mle_variance_constraint <- con$mle_variance_constraint
# ----- Estimate using roptim and initial values provided
output <- MSARmdl_mle(con$init_theta, init_mdl, k, optim_options)
output$theta_0 <- con$init_theta
output$init_used <- 1
}
}
roots   <- all(Mod(as.complex(polyroot(c(1,-output$phi))))>1)
# ----- Obtain variables of interest
theta_mu_ind <- c(rep(1, 1 + (k-1)*con$msmu), rep(0, 1 + (k-1)*con$msvar + p + k*k))
theta_sig_ind <- c(rep(0, 1 + (k-1)*con$msmu), rep(1, 1 + (k-1)*con$msvar), rep(0, p + k*k))
theta_var_ind <- theta_sig_ind
theta_phi_ind <- c(rep(0, 2 + (k-1)*con$msmu + (k-1)*con$msvar), rep(1, p), rep(0, k*k))
theta_P_ind <- c(rep(0, 2 + (k-1)*con$msmu + (k-1)*con$msvar + p), rep(1, k*k))
# ----- Output
p=2
con <- list(getSE = TRUE,
msmu = TRUE,
msvar = TRUE,
init_theta = NULL,
method = "EM",
maxit = 10000,
thtol = 1.e-6,
maxit_converge = 500,
use_diff_init = 1,
mle_stationary_constraint = TRUE,
mle_variance_constraint = 0.01)
# ----- Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
if(length(noNms <- namc[!namc %in% nmsC])){
warning("unknown names in control: ", paste(noNms,collapse=", "))
}
if (k<2){
stop("value for 'k' must be greater than or equal to 2.")
}
# ---------- Optimization options
optim_options <- list(maxit = con$maxit, thtol = con$thtol)
# pre-define list and matrix length for results
output_all <- list(con$use_diff_init)
max_loglik <- matrix(0, con$use_diff_init, 1)
# ---------- Estimate linear model to use for initial values & transformed series
init_control <- list(const = TRUE, getSE = FALSE)
init_mdl <- ARmdl(Y, p = p, init_control)
init_mdl$msmu <- con$msmu
init_mdl$msvar <- con$msvar
if (is.null(con$init_theta)==TRUE){
if (con$method=="EM"){
# ----- Estimate using 'use_diff_init' different initial values
for (xi in 1:con$use_diff_init){
init_used <- 0
converge_check <- FALSE
while ((converge_check==FALSE) & (init_used<con$maxit_converge)){
# ----- Initial values
theta_0 <- initVals_MSARmdl(init_mdl, k)
# ----- Estimate using EM algorithm and initial values provided
output_tmp <- MSARmdl_em(theta_0, init_mdl, k, optim_options)
# ----- Convergence check
logLike_tmp <- output_tmp$logLike
theta_tmp <- output_tmp$theta
converge_check <- ((is.finite(output_tmp$logLike)) & (all(is.finite(output_tmp$theta))))
init_used <- init_used + 1
}
output_tmp$theta_0 <- theta_0
max_loglik[xi] <- output_tmp$logLike
output_tmp$init_used <- init_used
output_all[[xi]] <- output_tmp
}
}else if (con$method=="MLE"){
init_mdl$mle_stationary_constraint <- con$mle_stationary_constraint
init_mdl$mle_variance_constraint <- con$mle_variance_constraint
# ----- Estimate using 'use_diff_init' different initial values
for (xi in 1:con$use_diff_init){
init_used <- 0
converge_check <- FALSE
while ((converge_check==FALSE) & (init_used<con$maxit_converge)){
# ----- Initial values
theta_0 <- initVals_MSARmdl(init_mdl, k)
# ----- Estimate using roptim and initial values provided
output_tmp <- NULL
try(
output_tmp <- MSARmdl_mle(theta_0, init_mdl, k, optim_options)
)
# ----- Convergence check
if (is.null(output_tmp)==FALSE){
converge_check <- TRUE
}else{
converge_check <- FALSE
}
init_used = init_used + 1
}
output_tmp$theta_0 <- theta_0
max_loglik[xi] <- output_tmp$logLike
output_tmp$init_used <- init_used
output_all[[xi]] <- output_tmp
}
}
if (con$use_diff_init==1){
output <- output_tmp
}else{
xl = which.max(max_loglik)
if (length(xl)==0){
warning("Model(s) did not converge. Use higher 'use_diff_init' or 'maxit_converge'.")
output <- output_all[[1]]
}else{
output <- output_all[[xl]]
}
}
}else{
if (con$method=="EM"){
# ----- Estimate using EM algorithm and initial values provided
output <- MSARmdl_em(con$init_theta, init_mdl, k, optim_options)
output$theta_0 <- con$init_theta
output$init_used <- 1
}else if (con$method=="MLE"){
init_mdl$mle_stationary_constraint <- con$mle_stationary_constraint
init_mdl$mle_variance_constraint <- con$mle_variance_constraint
# ----- Estimate using roptim and initial values provided
output <- MSARmdl_mle(con$init_theta, init_mdl, k, optim_options)
output$theta_0 <- con$init_theta
output$init_used <- 1
}
}
roots   <- all(Mod(as.complex(polyroot(c(1,-output$phi))))>1)
# ----- Obtain variables of interest
theta_mu_ind <- c(rep(1, 1 + (k-1)*con$msmu), rep(0, 1 + (k-1)*con$msvar + p + k*k))
theta_sig_ind <- c(rep(0, 1 + (k-1)*con$msmu), rep(1, 1 + (k-1)*con$msvar), rep(0, p + k*k))
theta_var_ind <- theta_sig_ind
theta_phi_ind <- c(rep(0, 2 + (k-1)*con$msmu + (k-1)*con$msvar), rep(1, p), rep(0, k*k))
theta_P_ind <- c(rep(0, 2 + (k-1)*con$msmu + (k-1)*con$msvar + p), rep(1, k*k))
# ----- Output
output$mu
output$sigma
control = list(msmu=FALSE,msvar=TRUE)
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,5),
sigma = c(1,2),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
Y<- y_ms_simu$y
con <- list(getSE = TRUE,
msmu = TRUE,
msvar = TRUE,
init_theta = NULL,
method = "EM",
maxit = 10000,
thtol = 1.e-6,
maxit_converge = 500,
use_diff_init = 1,
mle_stationary_constraint = TRUE,
mle_variance_constraint = 0.01)
# ----- Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
if(length(noNms <- namc[!namc %in% nmsC])){
warning("unknown names in control: ", paste(noNms,collapse=", "))
}
if (k<2){
stop("value for 'k' must be greater than or equal to 2.")
}
# ---------- Optimization options
optim_options <- list(maxit = con$maxit, thtol = con$thtol)
# pre-define list and matrix length for results
output_all <- list(con$use_diff_init)
max_loglik <- matrix(0, con$use_diff_init, 1)
# ---------- Estimate linear model to use for initial values & transformed series
init_control <- list(const = TRUE, getSE = FALSE)
init_mdl <- ARmdl(Y, p = p, init_control)
init_mdl$msmu <- con$msmu
init_mdl$msvar <- con$msvar
if (is.null(con$init_theta)==TRUE){
if (con$method=="EM"){
# ----- Estimate using 'use_diff_init' different initial values
for (xi in 1:con$use_diff_init){
init_used <- 0
converge_check <- FALSE
while ((converge_check==FALSE) & (init_used<con$maxit_converge)){
# ----- Initial values
theta_0 <- initVals_MSARmdl(init_mdl, k)
# ----- Estimate using EM algorithm and initial values provided
output_tmp <- MSARmdl_em(theta_0, init_mdl, k, optim_options)
# ----- Convergence check
logLike_tmp <- output_tmp$logLike
theta_tmp <- output_tmp$theta
converge_check <- ((is.finite(output_tmp$logLike)) & (all(is.finite(output_tmp$theta))))
init_used <- init_used + 1
}
output_tmp$theta_0 <- theta_0
max_loglik[xi] <- output_tmp$logLike
output_tmp$init_used <- init_used
output_all[[xi]] <- output_tmp
}
}else if (con$method=="MLE"){
init_mdl$mle_stationary_constraint <- con$mle_stationary_constraint
init_mdl$mle_variance_constraint <- con$mle_variance_constraint
# ----- Estimate using 'use_diff_init' different initial values
for (xi in 1:con$use_diff_init){
init_used <- 0
converge_check <- FALSE
while ((converge_check==FALSE) & (init_used<con$maxit_converge)){
# ----- Initial values
theta_0 <- initVals_MSARmdl(init_mdl, k)
# ----- Estimate using roptim and initial values provided
output_tmp <- NULL
try(
output_tmp <- MSARmdl_mle(theta_0, init_mdl, k, optim_options)
)
# ----- Convergence check
if (is.null(output_tmp)==FALSE){
converge_check <- TRUE
}else{
converge_check <- FALSE
}
init_used = init_used + 1
}
output_tmp$theta_0 <- theta_0
max_loglik[xi] <- output_tmp$logLike
output_tmp$init_used <- init_used
output_all[[xi]] <- output_tmp
}
}
if (con$use_diff_init==1){
output <- output_tmp
}else{
xl = which.max(max_loglik)
if (length(xl)==0){
warning("Model(s) did not converge. Use higher 'use_diff_init' or 'maxit_converge'.")
output <- output_all[[1]]
}else{
output <- output_all[[xl]]
}
}
}else{
if (con$method=="EM"){
# ----- Estimate using EM algorithm and initial values provided
output <- MSARmdl_em(con$init_theta, init_mdl, k, optim_options)
output$theta_0 <- con$init_theta
output$init_used <- 1
}else if (con$method=="MLE"){
init_mdl$mle_stationary_constraint <- con$mle_stationary_constraint
init_mdl$mle_variance_constraint <- con$mle_variance_constraint
# ----- Estimate using roptim and initial values provided
output <- MSARmdl_mle(con$init_theta, init_mdl, k, optim_options)
output$theta_0 <- con$init_theta
output$init_used <- 1
}
}
roots   <- all(Mod(as.complex(polyroot(c(1,-output$phi))))>1)
# ----- Obtain variables of interest
theta_mu_ind <- c(rep(1, 1 + (k-1)*con$msmu), rep(0, 1 + (k-1)*con$msvar + p + k*k))
theta_sig_ind <- c(rep(0, 1 + (k-1)*con$msmu), rep(1, 1 + (k-1)*con$msvar), rep(0, p + k*k))
theta_var_ind <- theta_sig_ind
theta_phi_ind <- c(rep(0, 2 + (k-1)*con$msmu + (k-1)*con$msvar), rep(1, p), rep(0, k*k))
theta_P_ind <- c(rep(0, 2 + (k-1)*con$msmu + (k-1)*con$msvar + p), rep(1, k*k))
# ----- Output
(con$msmu==FALSE)
(con$msvar==FALSE)
output$mu
matrix(output$mu, nrow=k, ncol=q, byrow=TRUE)
matrix(output$mu, nrow=k, ncol=1, byrow=TRUE)
library(MSTest)
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,10),
sigma = c(1,2),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSVARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=TRUE,msvar=TRUE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=2,k=2,burnin=100)
check= cbind(ysimu$St,ysimu$mu_t,ysimu$sigma_t)
check
mdl_h0$mu
mdl_h0$sigma
mdl_h0$msmu
mdl_h0$msvar
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,10),
sigma = c(1,2),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSVARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=TRUE,msvar=TRUE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=1,k=2,burnin=100)
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,10),
sigma = c(1,2),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=TRUE,msvar=TRUE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=1,k=2,burnin=100)
check= cbind(ysimu$St,ysimu$mu_t,ysimu$sigma_t)
check
mdl_h0$mu
mdl_h0$sigma
mdl_h0$msmu
mdl_h0$msvar
check= cbind(ysimu$St,ysimu$mu_t,ysimu$stdev_t)
check
mdl_h0$mu
mdl_h0$sigma
mdl_h0$msmu
mdl_h0$msvar
sqrt(mdl_h0$sigma)
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,5),
sigma = c(1,2),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=FALSE,msvar=TRUE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=1,k=2,burnin=100)
check= cbind(ysimu$St,ysimu$mu_t,ysimu$stdev_t)
check
mdl_h0$mu
sqrt(mdl_h0$sigma)
mdl_h0$msmu
mdl_h0$msvar
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,5),
sigma = c(1,1),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=FALSE,msvar=FALSE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=1,k=2,burnin=100)
check= cbind(ysimu$St,ysimu$mu_t,ysimu$stdev_t)
check
mdl_h0$mu
sqrt(mdl_h0$sigma)
mdl_h0$msmu
mdl_h0$msvar
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,10),
sigma = c(1,1),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=TRUE,msvar=FALSE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=1,k=2,burnin=100)
check= cbind(ysimu$St,ysimu$mu_t,ysimu$stdev_t)
check
mdl_h0$mu
sqrt(mdl_h0$sigma)
mdl_h0$msmu
mdl_h0$msvar
con <- list(N = 99,
burnin = 100,
converge_check = NULL,
workers = 0,
mdl_h0_control = list(),
mdl_h1_control = list(),
use_diff_init_sim = NULL)
(is.null(con$use_diff_init_sim)==FALSE)
library(MSTest)
library(MSTest)
library(foreach)
library(doParallel)
# ============================================================================ #
est_diff_init     <- 10   # Number of initial values of use when estimating
simu_diff_init    <- 5   # Number of initial values of use when estimating
seed <- 12345
# Optimization controls
N                 <- 99
Nsim              <- 1000
msmu              <- TRUE
msvar             <- TRUE
workers           <- 6
est_diff_init     <- 10   # Number of initial values of use when estimating
simu_diff_init    <- 1   # Number of initial values of use when estimating
#   models from simulated data (for null dist.)
lmc_control <- list(N = N,
mdl_h0_control = list(maxit = 1000,
thtol = 1e-6,
use_diff_init = est_diff_init),
mdl_h1_control = list(maxit = 1000,
thtol = 1e-6,
use_diff_init = est_diff_init),
use_diff_init_sim = simu_diff_init)
# Parameters of DGP (under null hypothesis)
k0          <- 2
ar_mdl_k2   <- list(k = k0)
mu_ls       <- c(0,2)
sigma_ls    <- c(1,2)
n_ls        <- c(100,200)
phi_ls      <- c(0.1, 0.9, 1)
P22_ls      <- c(0.90, 0.50)
# Number of regimes under alternative model
k1          <- 3
# ====================================================================
# ====== Parallel Loop
# ====================================================================
param_ls                  <- list()
param_ls$n                <- n_ls
param_ls$phi              <- phi_ls
param_ls$mu_ls            <- mu_ls
param_ls$sigma_ls         <- sigma_ls
param_ls$P22_ls           <- P22_ls
combined_list             <- expand.grid(param_ls)
combined_list["mu_1"]     <- 0
combined_list["sigma_1"]  <- 1
combined_list <- combined_list[((combined_list["mu_ls"]==0) + (combined_list["mu_1"]==0) + (combined_list["sigma_ls"]==1) + (combined_list["sigma_1"]==1))!=4,]
rownames(combined_list)   <- NULL
set.seed(seed)
i=1
n <- combined_list[i,1]
phi <- combined_list[i,2]
mu_1 <- combined_list[i,6]
mu_2 <- combined_list[i,3]
stdev_1 <- combined_list[i,7]
stdev_2 <- combined_list[i,4]
p22 <- combined_list[i,5]
# ------------- Model
ar_mdl_k2$n     <- n
ar_mdl_k2$phi   <- phi
ar_mdl_k2$mu    <- c(mu_1,mu_2)
ar_mdl_k2$sigma <- c(stdev_1,stdev_2)
ar_mdl_k2$P     <- cbind(c(0.9,0.10),c(1-p22,p22))
msmu            <- mu_1!=mu_2
msvar           <- stdev_1!=stdev_2
p               <- length(phi)
lmc_control$mdl_h0_control$msmu   <- msmu
lmc_control$mdl_h0_control$msvar  <- msvar
lmc_control$mdl_h1_control$msmu   <- msmu
LRTest_out <- NULL
attempt <- 0
startT <- proc.time()
y_out <- MSTest::simuMSAR(ar_mdl_k2)
LRTest_out <- MSTest::LMCLRTest(y_out$y, p, k0, k1, control = lmc_control)
endT <- proc.time()-startT
endT
res_line <- paste0(xi,',',attempt,',',endT[3],',',LRTest_out$LRT_0,',',LRTest_out$pval)
res_line
LRTest_out$control
est_diff_init     <- 10   # Number of initial values of use when estimating
simu_diff_init    <- 5   # Number of initial values of use when estimating
LRTest_out <- NULL
startT <- proc.time()
LRTest_out <- MSTest::LMCLRTest(y_out$y, p, k0, k1, control = lmc_control)
lmc_control <- list(N = N,
mdl_h0_control = list(maxit = 1000,
thtol = 1e-6,
use_diff_init = est_diff_init),
mdl_h1_control = list(maxit = 1000,
thtol = 1e-6,
use_diff_init = est_diff_init),
use_diff_init_sim = simu_diff_init)
LRTest_out <- NULL
startT <- proc.time()
LRTest_out <- MSTest::LMCLRTest(y_out$y, p, k0, k1, control = lmc_control)
endT <- proc.time()-startT
endT
2011/700
LRTest_out$pval
res_line
LRTest_out$LRT_0
