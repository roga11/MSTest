mdl_h0$mu
mdl_h0$sigma
mdl_h0$msmu
mdl_h0$msvar
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,10),
sigma = c(1,2),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSVARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=TRUE,msvar=TRUE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=1,k=2,burnin=100)
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,10),
sigma = c(1,2),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=TRUE,msvar=TRUE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=1,k=2,burnin=100)
check= cbind(ysimu$St,ysimu$mu_t,ysimu$sigma_t)
check
mdl_h0$mu
mdl_h0$sigma
mdl_h0$msmu
mdl_h0$msvar
check= cbind(ysimu$St,ysimu$mu_t,ysimu$stdev_t)
check
mdl_h0$mu
mdl_h0$sigma
mdl_h0$msmu
mdl_h0$msvar
sqrt(mdl_h0$sigma)
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,5),
sigma = c(1,2),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=FALSE,msvar=TRUE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=1,k=2,burnin=100)
check= cbind(ysimu$St,ysimu$mu_t,ysimu$stdev_t)
check
mdl_h0$mu
sqrt(mdl_h0$sigma)
mdl_h0$msmu
mdl_h0$msvar
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,5),
sigma = c(1,1),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=FALSE,msvar=FALSE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=1,k=2,burnin=100)
check= cbind(ysimu$St,ysimu$mu_t,ysimu$stdev_t)
check
mdl_h0$mu
sqrt(mdl_h0$sigma)
mdl_h0$msmu
mdl_h0$msvar
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 500,
mu    = c(5,10),
sigma = c(1,1),
phi   = c(0.5, 0.2),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
mdl_h0 <- MSTest::MSARmdl(y_ms_simu$y, p=1, k=2, control = list(msmu=TRUE,msvar=FALSE))
ysimu <- MSTest::simuMdl(mdl_h0,p=1,q=1,k=2,burnin=100)
check= cbind(ysimu$St,ysimu$mu_t,ysimu$stdev_t)
check
mdl_h0$mu
sqrt(mdl_h0$sigma)
mdl_h0$msmu
mdl_h0$msvar
con <- list(N = 99,
burnin = 100,
converge_check = NULL,
workers = 0,
mdl_h0_control = list(),
mdl_h1_control = list(),
use_diff_init_sim = NULL)
(is.null(con$use_diff_init_sim)==FALSE)
library(MSTest)
library(MSTest)
library(foreach)
library(doParallel)
# ============================================================================ #
est_diff_init     <- 10   # Number of initial values of use when estimating
simu_diff_init    <- 5   # Number of initial values of use when estimating
seed <- 12345
# Optimization controls
N                 <- 99
Nsim              <- 1000
msmu              <- TRUE
msvar             <- TRUE
workers           <- 6
est_diff_init     <- 10   # Number of initial values of use when estimating
simu_diff_init    <- 1   # Number of initial values of use when estimating
#   models from simulated data (for null dist.)
lmc_control <- list(N = N,
mdl_h0_control = list(maxit = 1000,
thtol = 1e-6,
use_diff_init = est_diff_init),
mdl_h1_control = list(maxit = 1000,
thtol = 1e-6,
use_diff_init = est_diff_init),
use_diff_init_sim = simu_diff_init)
# Parameters of DGP (under null hypothesis)
k0          <- 2
ar_mdl_k2   <- list(k = k0)
mu_ls       <- c(0,2)
sigma_ls    <- c(1,2)
n_ls        <- c(100,200)
phi_ls      <- c(0.1, 0.9, 1)
P22_ls      <- c(0.90, 0.50)
# Number of regimes under alternative model
k1          <- 3
# ====================================================================
# ====== Parallel Loop
# ====================================================================
param_ls                  <- list()
param_ls$n                <- n_ls
param_ls$phi              <- phi_ls
param_ls$mu_ls            <- mu_ls
param_ls$sigma_ls         <- sigma_ls
param_ls$P22_ls           <- P22_ls
combined_list             <- expand.grid(param_ls)
combined_list["mu_1"]     <- 0
combined_list["sigma_1"]  <- 1
combined_list <- combined_list[((combined_list["mu_ls"]==0) + (combined_list["mu_1"]==0) + (combined_list["sigma_ls"]==1) + (combined_list["sigma_1"]==1))!=4,]
rownames(combined_list)   <- NULL
set.seed(seed)
i=1
n <- combined_list[i,1]
phi <- combined_list[i,2]
mu_1 <- combined_list[i,6]
mu_2 <- combined_list[i,3]
stdev_1 <- combined_list[i,7]
stdev_2 <- combined_list[i,4]
p22 <- combined_list[i,5]
# ------------- Model
ar_mdl_k2$n     <- n
ar_mdl_k2$phi   <- phi
ar_mdl_k2$mu    <- c(mu_1,mu_2)
ar_mdl_k2$sigma <- c(stdev_1,stdev_2)
ar_mdl_k2$P     <- cbind(c(0.9,0.10),c(1-p22,p22))
msmu            <- mu_1!=mu_2
msvar           <- stdev_1!=stdev_2
p               <- length(phi)
lmc_control$mdl_h0_control$msmu   <- msmu
lmc_control$mdl_h0_control$msvar  <- msvar
lmc_control$mdl_h1_control$msmu   <- msmu
LRTest_out <- NULL
attempt <- 0
startT <- proc.time()
y_out <- MSTest::simuMSAR(ar_mdl_k2)
LRTest_out <- MSTest::LMCLRTest(y_out$y, p, k0, k1, control = lmc_control)
endT <- proc.time()-startT
endT
res_line <- paste0(xi,',',attempt,',',endT[3],',',LRTest_out$LRT_0,',',LRTest_out$pval)
res_line
LRTest_out$control
est_diff_init     <- 10   # Number of initial values of use when estimating
simu_diff_init    <- 5   # Number of initial values of use when estimating
LRTest_out <- NULL
startT <- proc.time()
LRTest_out <- MSTest::LMCLRTest(y_out$y, p, k0, k1, control = lmc_control)
lmc_control <- list(N = N,
mdl_h0_control = list(maxit = 1000,
thtol = 1e-6,
use_diff_init = est_diff_init),
mdl_h1_control = list(maxit = 1000,
thtol = 1e-6,
use_diff_init = est_diff_init),
use_diff_init_sim = simu_diff_init)
LRTest_out <- NULL
startT <- proc.time()
LRTest_out <- MSTest::LMCLRTest(y_out$y, p, k0, k1, control = lmc_control)
endT <- proc.time()-startT
endT
2011/700
LRTest_out$pval
res_line
LRTest_out$LRT_0
devtools::document()
library(MSTest)
devtools::document()
library(MSTest)
control = list()
con <- list(N = 99,
burnin = 100,
converge_check = NULL,
workers = 0,
type = "pso",
eps = 0.1,
CI_union = TRUE,
lambda = 100,
stationary_constraint = TRUE,
phi_low = NULL,
phi_upp = NULL,
variance_constraint = 0.01,
silence = FALSE,
threshold_stop = 1,
mdl_h0_control = list(getSE = TRUE),
mdl_h1_control = list(getSE = TRUE),
use_diff_init_sim = NULL,
type_control = list(maxit = 200))
con
set.seed(1234)
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 200,
mu    = c(5,10),
sigma = c(1,4),
phi   = c(0.5),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
library(MSTest)
set.seed(1234)
# Define DGP of MS AR process
mdl_ms2 <- list(n     = 200,
mu    = c(5,10),
sigma = c(1,4),
phi   = c(0.5),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSAR() function
y_ms_simu <- simuMSAR(mdl_ms2)
# Set options for model estimation
control <- list(msmu   = TRUE,
msvar  = TRUE,
method = "EM",
use_diff_init = 1)
# Estimate model
ms_mdl <- MSARmdl(y_ms_simu$y, p = 1, k = 2, control)
ms_mdl
mdl_h0 <- ms_mdl
theta_0 <- mdl_h0$theta
theta_0
k0 <- mdl_h0$k
# ----- Define lower & upper bounds for search
theta_low = theta_0 - con$eps
theta_upp = theta_0 + con$eps
# create ball around union of eps and 2*standard error (if set to true and SE are finite)
if ((con$CI_union==TRUE) & all(is.finite(mdl_h0$theta_se))){
theta_low <- apply(cbind(as.matrix(theta_0 - 2*c(mdl_h0$theta_se)), as.matrix(theta_low)), 1, FUN = min)
theta_upp <- apply(cbind(as.matrix(theta_0 + 2*c(mdl_h0$theta_se)), as.matrix(theta_upp)), 1, FUN = max)
}
# correct lower bound of variances to be in admissible region
sigma_ind <- mdl_h0$theta_var_ind
if (any(theta_low[sigma_ind==1]<=0)==TRUE){
theta_low[sigma_ind==1][theta_low[sigma_ind==1]<=0] = theta_0[sigma_ind==1][theta_low[sigma_ind==1]<=0]*con$variance_constraint
}
# correct transition probability bounds to be in admissible region
if (k0>1){
P_h0_ind <- mdl_h0$theta_P_ind
theta_low[P_h0_ind==1][theta_low[P_h0_ind==1]<0] <- 0
theta_upp[P_h0_ind==1][theta_upp[P_h0_ind==1]>1] <- 1
}
con$phi_low <- c(-0.99)
con$phi_upp <- c(0.99)
theta_low
phi_ind <- mdl_h0$theta_phi_ind
phi_ind
theta_low[phi_ind==1]
max(theta_low[phi_ind==1],con$phi_low)
ms_mdl <- MSARmdl(y_ms_simu$y, p = 4, k = 2, control)
mdl_h0  <- md_dl
mdl_h0  <- md_mdl
mdl_h0  <- ms_mdl
theta_0 <- mdl_h0$theta
k0 <- mdl_h0$k
# ----- Define lower & upper bounds for search
theta_low = theta_0 - con$eps
theta_upp = theta_0 + con$eps
# create ball around union of eps and 2*standard error (if set to true and SE are finite)
if ((con$CI_union==TRUE) & all(is.finite(mdl_h0$theta_se))){
theta_low <- apply(cbind(as.matrix(theta_0 - 2*c(mdl_h0$theta_se)), as.matrix(theta_low)), 1, FUN = min)
theta_upp <- apply(cbind(as.matrix(theta_0 + 2*c(mdl_h0$theta_se)), as.matrix(theta_upp)), 1, FUN = max)
}
# ----- Check that bounds respect admissible regions
# correct lower bound of variances to be in admissible region
sigma_ind <- mdl_h0$theta_var_ind
if (any(theta_low[sigma_ind==1]<=0)==TRUE){
theta_low[sigma_ind==1][theta_low[sigma_ind==1]<=0] = theta_0[sigma_ind==1][theta_low[sigma_ind==1]<=0]*con$variance_constraint
}
# correct transition probability bounds to be in admissible region
if (k0>1){
P_h0_ind <- mdl_h0$theta_P_ind
theta_low[P_h0_ind==1][theta_low[P_h0_ind==1]<0] <- 0
theta_upp[P_h0_ind==1][theta_upp[P_h0_ind==1]>1] <- 1
}
(is.null(con$phi_low)==FALSE)
phi_ind <- mdl_h0$theta_phi_ind
phi_ind
theta_low[phi_ind==1]
con$phi_low
rep(con$phi_low,4)
con$phi_low <- as.matrix(rep(con$phi_low,4))
con$phi_low
con$phi_upp <- -con$phi_low
con$phi_upp
theta_low[phi_ind==1]
rbind(as.matrix(theta_low[phi_ind==1]),con$phi_low)
cbind(as.matrix(theta_low[phi_ind==1]),con$phi_low)
max(cbind(as.matrix(theta_low[phi_ind==1]),con$phi_low))
rowMax(cbind(as.matrix(theta_low[phi_ind==1]),con$phi_low))
apply(cbind(as.matrix(theta_low[phi_ind==1]),con$phi_low), 1, function(x) max(x))
mdl_h0$theta
mdl_h0$theta[5] <- 0.95
theta_0 <- mdl_h0$theta
theta_0
k0 <- mdl_h0$k
# ----- Define lower & upper bounds for search
theta_low = theta_0 - con$eps
theta_upp = theta_0 + con$eps
# create ball around union of eps and 2*standard error (if set to true and SE are finite)
if ((con$CI_union==TRUE) & all(is.finite(mdl_h0$theta_se))){
theta_low <- apply(cbind(as.matrix(theta_0 - 2*c(mdl_h0$theta_se)), as.matrix(theta_low)), 1, FUN = min)
theta_upp <- apply(cbind(as.matrix(theta_0 + 2*c(mdl_h0$theta_se)), as.matrix(theta_upp)), 1, FUN = max)
}
# ----- Check that bounds respect admissible regions
# correct lower bound of variances to be in admissible region
sigma_ind <- mdl_h0$theta_var_ind
if (any(theta_low[sigma_ind==1]<=0)==TRUE){
theta_low[sigma_ind==1][theta_low[sigma_ind==1]<=0] = theta_0[sigma_ind==1][theta_low[sigma_ind==1]<=0]*con$variance_constraint
}
theta_upp
theta_low
(is.null(con$phi_low)==FALSE)
phi_ind <- mdl_h0$theta_phi_ind
theta_low[phi_ind==1]
theta_low[phi_ind==1] <- apply(cbind(as.matrix(theta_low[phi_ind==1]),as.matrix(con$phi_low)), 1, function(x) max(x))
theta_low[phi_ind==1]
as.matrix(con$phi_upp)
cbind(as.matrix(theta_upp[phi_ind==1]),as.matrix(con$phi_upp)
)
apply(cbind(as.matrix(theta_upp[phi_ind==1]),as.matrix(con$phi_upp)), 1, function(x) min(x))
theta_upp[phi_ind==1]
theta_upp[phi_ind==1] <- apply(cbind(as.matrix(theta_upp[phi_ind==1]),as.matrix(con$phi_upp)), 1, function(x) min(x))
theta_upp[phi_ind==1]
set.seed(1234)
# Define DGP of MS VAR process
mdl_msvar2 <- list(n     = 1000,
p     = 1,
q     = 2,
mu    = rbind(c(5, -2),
c(10, 2)),
sigma = list(rbind(c(5.0, 1.5),
c(1.5, 1.0)),
rbind(c(7.0, 3.0),
c(3.0, 2.0))),
phi   = rbind(c(0.50, 0.30),
c(0.20, 0.70)),
k     = 2,
P     = rbind(c(0.90, 0.10),
c(0.10, 0.90)))
# Simulate process using simuMSVAR() function
y_msvar_simu <- simuMSVAR(mdl_msvar2)
control <- list(msmu   = TRUE,
msvar  = TRUE,
method = "EM",
use_diff_init = 1)
y_msvar_mdl <- MSVARmdl(y_msvar_simu$y, p = 1, k = 2, control)
mdl_h0 <- y_msvar_mdl
theta_0 <- mdl_h0$theta
k0 <- mdl_h0$k
# ----- Define lower & upper bounds for search
theta_low = theta_0 - con$eps
theta_upp = theta_0 + con$eps
# create ball around union of eps and 2*standard error (if set to true and SE are finite)
if ((con$CI_union==TRUE) & all(is.finite(mdl_h0$theta_se))){
theta_low <- apply(cbind(as.matrix(theta_0 - 2*c(mdl_h0$theta_se)), as.matrix(theta_low)), 1, FUN = min)
theta_upp <- apply(cbind(as.matrix(theta_0 + 2*c(mdl_h0$theta_se)), as.matrix(theta_upp)), 1, FUN = max)
}
# ----- Check that bounds respect admissible regions
# correct lower bound of variances to be in admissible region
sigma_ind <- mdl_h0$theta_var_ind
if (any(theta_low[sigma_ind==1]<=0)==TRUE){
theta_low[sigma_ind==1][theta_low[sigma_ind==1]<=0] = theta_0[sigma_ind==1][theta_low[sigma_ind==1]<=0]*con$variance_constraint
}
# correct transition probability bounds to be in admissible region
if (k0>1){
P_h0_ind <- mdl_h0$theta_P_ind
theta_low[P_h0_ind==1][theta_low[P_h0_ind==1]<0] <- 0
theta_upp[P_h0_ind==1][theta_upp[P_h0_ind==1]>1] <- 1
}
(mdl_h0$p>0)
phi_ind <- mdl_h0$theta_phi_ind
phi_ind
theta_low[phi_ind==1]
apply(cbind(as.matrix(theta_low[phi_ind==1]),as.matrix(con$phi_low)), 1, function(x) max(x))
theta_low[phi_ind==1] <- apply(cbind(as.matrix(theta_low[phi_ind==1]),as.matrix(con$phi_low)), 1, function(x) max(x))
theta_upp[phi_ind==1]
apply(cbind(as.matrix(theta_upp[phi_ind==1]),as.matrix(con$phi_upp)), 1, function(x) min(x))
devtools::document()
library(MSTest)
set.seed(1)
## Rastrigin function
out <- psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(abstol=1e-8))
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(abstol=1e-8))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=100))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=50))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=100))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=1000))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=1000000))
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=1000000,trace=1,silence=FALSE))
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=1000000,trace=1,silencverbosee=FALSE,abstol=1e-8))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=50,trace=1,silencverbosee=FALSE,abstol=1e-8))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=100,trace=1,silencverbosee=FALSE,abstol=1e-8))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=100,trace=1,verbose=FALSE,abstol=1e-8))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=100,trace=1,verbose=FALSE,abstol=1e-8))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=100,trace=1,abstol=1e-8))
out
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=100,trace=1,abstol=1e-8,trace.stats=TRUE))
out
out$par
out$value
out$counts
out$convergence
st <- out$stats
set.seed(1)
## Rastrigin function
out <- pso::psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
lower=-5,upper=5,control=list(maxit=100,trace=1,abstol=1e-8,trace.stats=TRUE,maxf=1000))
out$par
out$value
out$counts
out$convergence
st <- out$stats
