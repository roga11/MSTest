y84 <- as.matrix(hamilton84GNP$GNP_logdiff)
Y <- y84
hlrt_control  <- list(ix = 1,
iv = 0,
iq = 0,
gn = 20,
pn = 17,
pn_step_size = 0.05,
nwband = 4,
reps = 1000)
st <- Sys.time()
hlrt <- HLRTest(Y, p = 4, control = hlrt_control)
end <- Sys.time() - st
end
hlrt$`Test-Stat`
hlrt$params
hlrt$`p-value`
setwd("/Users/grodriguezrondon/Dropbox/Res/papers/MSTest_Rpack/jss-article-rnw")
Sweave("article.Rnw")
library("jsss")
library("jss")
install.packages("jss")
library("jss")
tinytex::tlmgr_install("orcidlink")
y84 <- as.matrix(hamilton84GNP$GNP_logdiff)
library(MSTest)
y84 <- as.matrix(hamilton84GNP$GNP_logdiff)
Y <- y84
p=4
control = list()
con <- list(ix = 1,
msvar = FALSE,
qbound = FALSE,
gridsize = 20,
p_gridsize = 12,
p_stepsize = 0.075,
mugrid_from = 0.1,
mugrid_by  = 0.1,
siggrid_from = 0.1,
siggrid_by  = 0.1,
N = 1000,
nwband  = 4,
sig_min = 0.01)
# Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
if(length(noNms <- namc[!namc %in% nmsC])){
warning("unknown names in control: ", paste(noNms,collapse=", "))
}
# Estimate Model under Null Hypothesis
if(p>0){
mdl_h0 <- ARmdl(Y, p, list(const = TRUE, getSE = TRUE))
}else if(p == 0){
mdl_h0 <- Nmdl(Y, list(const = TRUE, getSE = TRUE))
}else{
stop("Value for 'p' must be an integer >=0.")
}
HLR_opt_ls <- con
HLR_opt_ls$y    <- mdl_h0$y
HLR_opt_ls$x    <- mdl_h0$X
HLR_opt_ls$k    <- ncol(mdl_h0$X)
HLR_opt_ls$kx   <- length(con$ix)
HLR_opt_ls$k1   <- HLR_opt_ls$kx + con$msvar
HLR_opt_ls$b1   <- matrix(0, HLR_opt_ls$k, 1)
HLR_opt_ls$p    <- 0 # under null hypothesis
HLR_opt_ls$q    <- 0 # under null hypothesis
gp    <- seq(from = 0.1, by = con$p_stepsize, to = (con$p_gridsize-1)*con$p_stepsize+0.1)
gq    <- gp
gmu   <- as.matrix(seq(from = con$mugrid_from, by = con$mugrid_by, length.out = con$gridsize))
gar   <- matrix(rep(seq(from = -1, to = 1, length.out = con$gridsize), HLR_opt_ls$kx-1), nrow = con$gridsize, ncol = HLR_opt_ls$kx-1)
gsig  <- matrix(rep(seq(from = con$mugrid_from, by = con$mugrid_by, length.out = con$gridsize), con$msvar), nrow = con$gridsize, ncol = con$msvar)
gx    <- do.call(expand.grid, as.data.frame(cbind(gmu, gar, gsig)))
b <- c(mdl_h0$coef,mdl_h0$stdev)
null <- clike(b, HLR_opt_ls)
k         <- HLR_opt_ls$k
y         <- HLR_opt_ls$y
k1        <- HLR_opt_ls$k1
qbound    <- HLR_opt_ls$qbound
reps      <- HLR_opt_ls$N
nwband    <- HLR_opt_ls$nwband
mnull     <- sum(null)
gnn <- nrow(gx)
cnum <- length(gp)*gnn
if (qbound == FALSE){
cnum <- cnum*length(gq)
}
ny <- length(y)
eps <- matrix(rnorm((ny+nwband)*reps), nrow=(ny+nwband), ncol=reps)
draws <- matrix(1,nrow=1+nwband,ncol=reps)*(-1000)
drawsLs <- list()
c <- matrix(0, nrow = cnum, ncol = 1)
cs <- c
beta <- matrix(0, nrow = k + 3 + k1 - qbound, ncol = cnum) # All parameters
j <- 0
HLR_opt_ls_tmp <- HLR_opt_ls
lowb <- rep(NULL, length(b))
lowb[length(b)] <- HLR_opt_ls$var_min
uppb <- rep(NULL, length(b))
i1=1
for (i1 in 1:length(gp)){
print(i1)
HLR_opt_ls_tmp$p <- gp[i1]
i2 <- 1
while (i2 <=length(gq)){
if (qbound == TRUE){
HLR_opt_ls_tmp$q <- 1 - HLR_opt_ls_tmp$p
i2 <- length(gq)+1
}else{
HLR_opt_ls_tmp$q  <- gq[i2]
i2 <- i2 + 1
}
bs <- b # starting values for optim
for (xi in 1:nrow(gx)){
j <- j+1
HLR_opt_ls_tmp$b1 <- as.matrix(gx[xi,]) #value for constant in regime 2
# Optimization (optimal theta which contains constant in regime 1, ar coefs, and variance)
optlst <- optim(bs, mclike, dmclike, HLR_opt_ls = HLR_opt_ls_tmp, method = 'BFGS')
bnew <- optlst$par
f <- optlst$value
beta[1:(k+1),j] <- bnew
beta[(k+2):(k+1+k1),j] <- HLR_opt_ls_tmp$b1
beta[(k+2+k1),j] <- HLR_opt_ls_tmp$p
if (qbound == FALSE){
beta[(k+3+k1),j] <- HLR_opt_ls_tmp$q
}
diff <- null - clike(bnew, HLR_opt_ls_tmp)
diff <- diff - mean(diff)
se <- as.numeric(sqrt(t(diff)%*%diff))
diff <- (diff/se)
c[j] <- mnull - f
cs[j] <- ((mnull-f)/se)
diffe <- matrix(0, nrow = 1, ncol = reps)
nw <- 0
while (nw<=nwband){
diffe <- diffe+t(diff)%*%eps[(1+nw):(ny+nw),]
draws[(1+nw),] <- apply(rbind(draws[(1+nw),],(diffe/sqrt(1+nw))),2,max)
nw <- nw+1
}
drawsLs[[j]] <- draws
bs <- bnew
}
}
}
out <- list(cs = cs, draws = drawsLS, coefficients = t(beta))
out <- list(cs = cs, draws = drawsLs, coefficients = t(beta))
LR_stat <- max(out$cs)
LR_stat
coef <- as.matrix(out$coefficients[which.max(out$cs),])
out$draws[[which.max(out$cs)]]
dim(out$draws[[which.max(out$cs)]])
t(out$draws[[which.max(out$cs)]])
apply(t(out$draws[[which.max(out$cs)]]),2,sort)
draws <- apply(t(out$draws[[which.max(out$cs)]]),2,sort)
if (con$msvar == FALSE){
signame_tmp_0 <-  "sig"
signame_tmp_1 <-  NULL
}else{
signame_tmp_0 <- "sig_0"
signame_tmp_1 <- "sig_1"
}
if (length(con$ix)>1){
rname_tmp <- c("const_0", paste0("ar", seq(1, (HLR_opt_ls$k-1)),"_0"), signame_tmp_0,
"const_1", paste0("ar", con$ix[2:length(con$ix)]-1,"_1"), signame_tmp_1)
}else{
rname_tmp <- c("const_0", paste0("ar", seq(1, (HLR_opt_ls$k-1)),"_0"), signame_tmp_0,
"const_1", signame_tmp_1)
}
rname_tmp <- c(rname_tmp, "p")
if (con$qbound == FALSE){
rname_tmp <- c(rname_tmp, "q")
}
rownames(coef) <- rname_tmp
draws>LR_stat
colMeans(draws>LR_stat)
round(cr*reps)
cr <- c(0.9, 0.95, 0.99)
round(cr*reps)
draws[round(cr*reps),]
as.matrix(draws[round(cr*reps),])
cu <- as.matrix(draws[round(cr*reps),])
pvalue
pvalue <- colMeans(draws>LR_stat)
pvalue
pvalue <- as.matrix(colMeans(draws>LR_stat))
pvalue
cu <- t(as.matrix(draws[round(cr*reps),]))
cu
colnames(cu) <- c('0.90 %', '0.95 %', '0.99 %')
cu
0:(con$nwband)
paste0("M = ",0:(con$nwband))
rownames(cu) <- paste0("M = ",0:(con$nwband))
cu
rownames(pvalue) <- paste0("M = ",0:(con$nwband))
pvalue
HLRTest_output <- list(mdl_h0 = mdl_h0, LR0 = LR_stat, LRN = draws, LR_cv = cu,
pval = pvalue, coef = coef)
HLRTest_output
colnames(draws) <- paste0("M = ",0:(con$nwband))
draws
HLRTest_output <- list(mdl_h0 = mdl_h0, LR0 = LR_stat, LRN = draws, LR_cv = cu,
pval = pvalue, coef = coef)
class(HLRTest_output) <- "HLRTest"
lowb
lowb <- rep(NULL, length(b))
lowb
b <- c(mdl_h0$coef,mdl_h0$stdev)
b
lowb <- rep(NULL, length(b))
lowb
length(b)
rep(NULL, length(b))
rep(1, length(b))
rep(NULL, length(b))
rep(-Inf, length(b))
lowb[length(b)] <- HLR_opt_ls$var_min
lowb
lowb <- rep(-Inf, length(b))
lowb[length(b)] <- HLR_opt_ls$var_min
lowb
length(b)
lowb[length(b)]
HLR_opt_ls$var_min
HLR_opt_ls$sig_min
lowb[length(b)] <- HLR_opt_ls$sig_min
lowb
uppb <- rep(Inf, length(b))
bs <- b # starting values for optim
optlst <- optim(bs, mclike, dmclike, HLR_opt_ls = HLR_opt_ls_tmp, method = 'BFGS', lower = lowb, upper = uppb)
optlst <- optim(bs, mclike, dmclike, HLR_opt_ls = HLR_opt_ls_tmp, method = 'L-BFGS-B', lower = lowb, upper = uppb)
optlst
library(MSTest)
devtools::document()
devtools::document()
library(MSTest)
hlrt_control  <- list(ix = 1,
p_gridsize = 17,
p_stepsize = 0.05)
st <- Sys.time()
hlrt <- HLRTest(Y, p = 4, control = hlrt_control)
y84 <- as.matrix(hamilton84GNP$GNP_logdiff)
Y <- y84
hlrt_control  <- list(ix = 1,
p_gridsize = 17,
p_stepsize = 0.05)
st <- Sys.time()
hlrt <- HLRTest(Y, p = 4, control = hlrt_control)
devtools::document()
library(MSTest)
y84 <- as.matrix(hamilton84GNP$GNP_logdiff)
Y <- y84
hlrt_control  <- list(ix = 1,
p_gridsize = 17,
p_stepsize = 0.05)
st <- Sys.time()
hlrt <- HLRTest(Y, p = 4, control = hlrt_control)
library(MSTest)
y84 <- as.matrix(hamilton84GNP$GNP_logdiff)
Y <- y84
hlrt_control  <- list(ix = 1,
p_gridsize = 17,
p_stepsize = 0.05)
st <- Sys.time()
hlrt <- HLRTest(Y, p = 4, control = hlrt_control)
end <- Sys.time() - st
end
hlrt
HLRTest_output
hlrt
mdl <- hlrt
cat("\nRestricted Model\n")
frame_tmp <- data.frame(coef = mdl$mdl_h0$theta)
if (mdl$mdl_h0$control$getSE==TRUE){
frame_tmp["s.e."] <- mdl$mdl_h0$theta_se
}
rownames(frame_tmp) <- names(mdl$mdl_h0$theta)
mdl$control$msvar
con
contorl
con <- list(ix = 1,
msvar = FALSE,
qbound = FALSE,
gridsize = 20,
p_gridsize = 12,
p_stepsize = 0.075,
mugrid_from = 0.1,
mugrid_by  = 0.1,
siggrid_from = 0.1,
siggrid_by  = 0.1,
N = 1000,
nwband  = 4,
sig_min = 0.01)
# Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
control = list()
con <- list(ix = 1,
msvar = FALSE,
qbound = FALSE,
gridsize = 20,
p_gridsize = 12,
p_stepsize = 0.075,
mugrid_from = 0.1,
mugrid_by  = 0.1,
siggrid_from = 0.1,
siggrid_by  = 0.1,
N = 1000,
nwband  = 4,
sig_min = 0.01)
# Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
if(length(noNms <- namc[!namc %in% nmsC])){
warning("unknown names in control: ", paste(noNms,collapse=", "))
}
# Estimate Model under Null Hypothesis
if(p>0){
mdl_h0 <- ARmdl(Y, p, list(const = TRUE, getSE = TRUE))
}else if(p == 0){
mdl_h0 <- Nmdl(Y, list(const = TRUE, getSE = TRUE))
}else{
stop("Value for 'p' must be an integer >=0.")
}
p=4
con <- list(ix = 1,
msvar = FALSE,
qbound = FALSE,
gridsize = 20,
p_gridsize = 12,
p_stepsize = 0.075,
mugrid_from = 0.1,
mugrid_by  = 0.1,
siggrid_from = 0.1,
siggrid_by  = 0.1,
N = 1000,
nwband  = 4,
sig_min = 0.01)
# Perform some checks for controls
nmsC <- names(con)
con[(namc <- names(control))] <- control
if(length(noNms <- namc[!namc %in% nmsC])){
warning("unknown names in control: ", paste(noNms,collapse=", "))
}
# Estimate Model under Null Hypothesis
if(p>0){
mdl_h0 <- ARmdl(Y, p, list(const = TRUE, getSE = TRUE))
}else if(p == 0){
mdl_h0 <- Nmdl(Y, list(const = TRUE, getSE = TRUE))
}else{
stop("Value for 'p' must be an integer >=0.")
}
mdl$control = con
(mdl$control$msvar)
mdl$LR0
mdl$LR_cv
mdl$pval
rbind(mdl$LR0, mdl$LR_cv, mdl$pval)
rbind(mdl$LR0, mdl$LR_cv, mdl$pval)
mdl$LR0
rbind(as.matrix(mdl$LR0), mdl$LR_cv, mdl$pval)
cbind(mdl$LR0, mdl$LR_cv, mdl$pval)
out <- data.frame(cbind(mdl$LR0, mdl$LR_cv, mdl$pval))
colnames(out) <- c("test-stat", names(mdl$supTS_cv), "p-value")
out
digits = getOption("digits")
cat("\nRestricted Model\n")
frame_tmp <- data.frame(coef = mdl$mdl_h0$theta)
if (mdl$mdl_h0$control$getSE==TRUE){
frame_tmp["s.e."] <- mdl$mdl_h0$theta_se
}
rownames(frame_tmp) <- names(mdl$mdl_h0$theta)
print(format(signif(frame_tmp, max(1L, digits - 2L))))
cat(paste("\nlog-likelihood = "),mdl$mdl_h0$logLike)
cat(paste("\nAIC = "),mdl$mdl_h0$AIC)
cat(paste("\nBIC = "),mdl$mdl_h0$BIC)
cat("\n")
if (mdl$control$msvar){
cat("\nHansen (1992) Likelihood Ratio Bound Test -  Switch in Mean and Variance\n")
}else{
cat("\nHansen (1992) Likelihood Ratio Bound Test -  Switch in Mean only\n")
}
out <- data.frame(cbind(mdl$LR0, mdl$LR_cv, mdl$pval))
colnames(out) <- c("test-stat", names(mdl$supTS_cv), "p-value")
print(format(signif(out, max(1L, digits - 2L))))
invisible(mdl)
USGNP <- read.table('inst/extdata/GNP22.csv', sep = ',', header = T)
USGNP[2:nrow(USGNP),3] <- diff(log(USGNP[,2]))*100
USGNP <- USGNP[2:nrow(USGNP), c(1,3,2)]
colnames(USGNP) <- c('DATE','GNP_logdiff','GNP')
usethis::use_data(USGNP, overwrite = TRUE)
GNPC96 <- read.table('inst/extdata/GNPC96.txt', sep = ',', header = F)
#setwd(paste0(Dir,'/MSTest/data'))
date <- seq(as.Date("1951/1/1"), as.Date("2010/10/1"), "quarter")
GNP_change = 100*diff(log(GNPC96$V1))
chp10GNP <- data.frame(date[2:length(date)],GNP_change,GNPC96$V1[2:length(date)])
colnames(chp10GNP) <- c('DATE','GNP_logdiff','GNP')
#save(chp10GNP,file = "chp10GNP")
usethis::use_data(chp10GNP, overwrite = TRUE)
hamilton84GNP <- read.table('inst/extdata/GNP82.DAT', header = F)
#setwd(paste0(Dir,'/MSTest/data'))
date <- seq(as.Date("1951/1/1"), as.Date("1984/10/1"), "quarter")
GNP <- matrix(0, dim(hamilton84GNP)[1]*dim(hamilton84GNP)[2], 1 )
xk <- 1
for (xi in 1:dim(hamilton84GNP)[1] ){
for (xj in 1:dim(hamilton84GNP)[2]){
GNP[xk] <- hamilton84GNP[xi,xj]
xk <- xk +1
}
}
date <- date[2:length(date)]
Tsize <- length(GNP)
Y <- matrix(0, Tsize-1, 1)
Y <- 100*( log(GNP[2:Tsize]) -log(GNP[1:(Tsize-1)]) )
hamilton84GNP <- data.frame(date,Y,GNP[2:Tsize])
colnames(hamilton84GNP) <- c('DATE','GNP_logdiff','GNP')
#save(hamilton84GNP,file = "hamilton84GNP")
usethis::use_data(hamilton84GNP, overwrite = TRUE)
usethis::use_data_raw("MSTest_raw_pckg_data")
devtools::document()
devtools::document()
devtools::document()
devtools::document()
version
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
library(MSTest)
library(MSTest)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
foreach
library(foreach)
library(numDeriv)
library(numDeriv)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
y84 <- as.matrix(hamilton84GNP$GNP_logdiff)
Y <- y84
hlrt_control  <- list(ix = 1,
p_gridsize = 17,
p_stepsize = 0.05)
st <- Sys.time()
hlrt <- HLRTest(Y, p = 4, control = hlrt_control)
end <- Sys.time() - st
end
hlrt
mdl = hlrt
out <- data.frame(cbind(mdl$LR0, mdl$LR_cv, mdl$pval))
out
colnames(out) <- c("test-stat", names(mdl$supTS_cv), "p-value")
out
colnames(out) <- c("test-stat", names(mdl$LR_cv), "p-value")
out
out <- data.frame(cbind(mdl$LR0, mdl$LR_cv, mdl$pval))
colnames(out) <- c("test-stat", names(mdl$LR_cv), "p-value")
out
names(mdl$LR_cv)
mdl$LR_cv
rownames(mdl$LR_cv)
colnames(out) <- c("test-stat", rownames(mdl$LR_cv), "p-value")
out
colnames(out) <- c("test-stat", rownames(mdl$LR_cv), "p-value")
out
mdl$LR_cv
colnames(out) <- c("test-stat", colnames(mdl$LR_cv), "p-value")
out
devtools::document()
library(MSTest)
hlrt
stats::rnorm()
stats::rnorm(100)
stats::nlswi
wi
simdist_N<-100
Tsize<-100
S_N2  <- sim_DLmoments(Tsize, simdist_N)
x     <- apply(S_N2, 2, sort)
Fx    <- approx_dist_loop(x)
a_start <- 0.01
b_start <- 0.01
# initiate matrix
a<-matrix(nrow=1,ncol=0)
b<-matrix(nrow=1,ncol=0)
i=1
mdl <- stats::nls(Fx[,i]~exp(alpha+beta*x[,i])/(1+exp(alpha+beta*x[,i])),
start=list(alpha=a_start,beta=b_start))
mdl
coef(mdl)
stats::coef()
stats::coef(mdl)
devtools::document()
devtools::document()
library(MSTest)
devtools::document()
library(MSTest)
devtools::document()
library(MSTest)
devtools::document()
devtools::document()
library(MSTest)
devtools::document()
library(MSTest)
devtools::document()
library(MSTest)
devtools::document()
library(MSTest)
