% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/models.R
\name{VARmdl}
\alias{VARmdl}
\title{Vector autoregressive model}
\usage{
VARmdl(Y, p, control = list())
}
\arguments{
\item{Y}{matrix of observations with dimension (n x q)}

\item{p}{integer determining the number of autoregressive lags}

\item{control}{List with model options including:
\itemize{
\item{const - }{boolean determining whether to estimate model with constant, if 'TRUE', or not, if 'FALSE'.}
\item{getSE - }{boolean determining whether to compute standard errors of parameters, if 'TRUE', or not, if 'FALSE'.}
}}
}
\value{
List with model attributes which include:
\itemize{
  \item{y - }{vector of observations of dimension (n x q).}
  \item{X - }{matrix of lagged observations (with or without vector of 1s depending on const='TRUE' or const='FALSE').}
  \item{x - }{matrix of lagged observations without vector of 1s.}
  \item{resid - }{vector of residuals.}
  \item{mu - }{vector of dimension (q x 1) containing means of each process.}
  \item{coef - }{coefficient estimates. This is the same as phi if const='FALSE'.}
  \item{intercept - }{vector of dimension (q x 1) containing coefficient estimate of intercepts.}
  \item{phi - }{matrix of dimension (q x q*p) autoregressive coefficient estimates. This is the same as coef if const='FALSE'.}
  \item{stdev - }{standard deviations of each process (i.e., square root of diagonal of 'sigma'.)}
  \item{sigma - }{covariance matrix.}
  \item{theta - }{vector containing: mu, vech(sigma), and phi.}
  \item{theta_mu_ind - }{vector indicating location of mean.}
  \item{theta_sig_ind - }{vector indicating location of variance.}
  \item{theta_phi_ind - }{vector indicating location of autoregressive coefficients.}
  \item{stationary - }{bool indicating if process is stationary 'TRUE' or non-stationary 'FALSE'.}
  \item{n - }{number of observations after transofrmation due to lags (i.e., T-p observations).}
  \item{p - }{number of autoregressive lags.}
  \item{q - }{number of serires.}
  \item{k - }{number of regimes. This is always 1 in VARmdl.}
  \item{Fmat - }{matrix of dimension (qp x qp) of companion form.}
  \item{logLike - }{log-likelihood.}
  \item{Hess - }{Hessian matrix. Approximated using numDeriv package and only returned if getSE='TRUE'.}
  \item{info_mat - }{Information matrix. Computed as the inverse of -Hess which is approximated using numDeriv package. If matrix is not PD then nearest PD matrix is obtained using nearPD. Only returned if getSE='TRUE'.}
  \item{nearPD_used - }{Bool determining whether nearPD was used on infoMat 'TRUE' or not 'FALSE'. Only returned if getSE='TRUE'.}
  \item{theta_se - }{standard errors of parameters in theta. Only returned if getSE='TRUE'.}
}
}
\description{
This function estimates a vector autoregresive model
}
\examples{
# -------------------------- Bivariate VAR(1) process --------------------------
set.seed(1234)
# Define DGP of VAR process
mdl_var <- list(n     = 1000, 
                p     = 1,
                mu    = c(5,-2),
                sigma = rbind(c(5.0, 1.5),
                              c(1.5, 1.0)),
                phi   = rbind(c(0.50, 0.30),
                              c(0.20, 0.70)))

# Simulate process using simuVAR() function
y_simu <- simuVAR(mdl_var)

# Set options for model estimation
control <- list(const  = TRUE, 
                getSE  = TRUE)

# Estimate model
y_var_mdl <- VARmdl(y_simu$y, p = 1, control)

y_var_mdl

# ----------------------- VAR(2) process with 3 variables ----------------------
set.seed(1234)
# Define DGP of VAR process
mdl_3var2 <- list(n     = 1000, 
                  p     = 2,
                  mu    = c(5,-2,1),
                  sigma = rbind(c(5.0, 1.5, 2.5),
                                c(1.5, 1.0, 1.5),
                                c(2.5, 1.5, 4.2)),
                  phi   = rbind(c(0.70, 0.30, 0.35,  -0.50, -0.20,   0.25),
                                c(0.20, 0.40, 0.35,  -0.30,  0.30,   0.25),
                                c(0.20, 0.30, 0.50,  -0.30, -0.20,  -0.40)))

# Simulate process using simuVAR() function
y3var2_simu <- simuVAR(mdl_3var2)

# Set options for model estimation
control <- list(const  = TRUE, 
                getSE  = TRUE)

# Estimate model
y_3var2_mdl <- VARmdl(y3var2_simu$y, p = 2, control)

y_3var2_mdl
}
\seealso{
\code{\link{MSVARmdl}}
}
